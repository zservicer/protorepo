// source: proto/talk.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {missingRequire} reports error on implicit type usages.
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
/* eslint-disable */
// @ts-nocheck

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

goog.exportSymbol('proto.CheckTokenRequest', null, global);
goog.exportSymbol('proto.CheckTokenResponse', null, global);
goog.exportSymbol('proto.CreateTokenRequest', null, global);
goog.exportSymbol('proto.CreateTokenResponse', null, global);
goog.exportSymbol('proto.Empty', null, global);
goog.exportSymbol('proto.LoginRequest', null, global);
goog.exportSymbol('proto.LoginResponse', null, global);
goog.exportSymbol('proto.QueryTalksRequest', null, global);
goog.exportSymbol('proto.QueryTalksResponse', null, global);
goog.exportSymbol('proto.RegisterRequest', null, global);
goog.exportSymbol('proto.RegisterResponse', null, global);
goog.exportSymbol('proto.ServiceAttachRequest', null, global);
goog.exportSymbol('proto.ServiceAttachTalkResponse', null, global);
goog.exportSymbol('proto.ServiceAttachedTalksResponse', null, global);
goog.exportSymbol('proto.ServiceDetachRequest', null, global);
goog.exportSymbol('proto.ServiceDetachTalkResponse', null, global);
goog.exportSymbol('proto.ServiceMessageConfirmed', null, global);
goog.exportSymbol('proto.ServicePendingTalksResponse', null, global);
goog.exportSymbol('proto.ServicePostMessage', null, global);
goog.exportSymbol('proto.ServiceQueryAttachedTalksRequest', null, global);
goog.exportSymbol('proto.ServiceQueryPendingTalksRequest', null, global);
goog.exportSymbol('proto.ServiceReloadTalkRequest', null, global);
goog.exportSymbol('proto.ServiceRequest', null, global);
goog.exportSymbol('proto.ServiceRequest.RequestCase', null, global);
goog.exportSymbol('proto.ServiceResponse', null, global);
goog.exportSymbol('proto.ServiceResponse.ResponseCase', null, global);
goog.exportSymbol('proto.ServiceTalkClose', null, global);
goog.exportSymbol('proto.ServiceTalkInfoAndMessages', null, global);
goog.exportSymbol('proto.ServiceTalkMessageResponse', null, global);
goog.exportSymbol('proto.ServiceTalkNotifyResponse', null, global);
goog.exportSymbol('proto.ServiceTalkReloadResponse', null, global);
goog.exportSymbol('proto.TalkClose', null, global);
goog.exportSymbol('proto.TalkCreateRequest', null, global);
goog.exportSymbol('proto.TalkInfo', null, global);
goog.exportSymbol('proto.TalkKickOutMessage', null, global);
goog.exportSymbol('proto.TalkMessage', null, global);
goog.exportSymbol('proto.TalkMessage.MessageCase', null, global);
goog.exportSymbol('proto.TalkMessageConfirmed', null, global);
goog.exportSymbol('proto.TalkMessageW', null, global);
goog.exportSymbol('proto.TalkMessageW.MessageCase', null, global);
goog.exportSymbol('proto.TalkMessages', null, global);
goog.exportSymbol('proto.TalkNotifyResponse', null, global);
goog.exportSymbol('proto.TalkOpenRequest', null, global);
goog.exportSymbol('proto.TalkRequest', null, global);
goog.exportSymbol('proto.TalkRequest.TalkCase', null, global);
goog.exportSymbol('proto.TalkResponse', null, global);
goog.exportSymbol('proto.TalkResponse.TalkCase', null, global);
goog.exportSymbol('proto.TalkStatus', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.Empty = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.Empty, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.Empty.displayName = 'proto.Empty';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.TalkKickOutMessage = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.TalkKickOutMessage, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.TalkKickOutMessage.displayName = 'proto.TalkKickOutMessage';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.QueryTalksRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.QueryTalksRequest.repeatedFields_, null);
};
goog.inherits(proto.QueryTalksRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.QueryTalksRequest.displayName = 'proto.QueryTalksRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.TalkInfo = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.TalkInfo, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.TalkInfo.displayName = 'proto.TalkInfo';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.QueryTalksResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.QueryTalksResponse.repeatedFields_, null);
};
goog.inherits(proto.QueryTalksResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.QueryTalksResponse.displayName = 'proto.QueryTalksResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.TalkCreateRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.TalkCreateRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.TalkCreateRequest.displayName = 'proto.TalkCreateRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.TalkOpenRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.TalkOpenRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.TalkOpenRequest.displayName = 'proto.TalkOpenRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.TalkMessageW = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.TalkMessageW.oneofGroups_);
};
goog.inherits(proto.TalkMessageW, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.TalkMessageW.displayName = 'proto.TalkMessageW';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.TalkMessage = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.TalkMessage.oneofGroups_);
};
goog.inherits(proto.TalkMessage, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.TalkMessage.displayName = 'proto.TalkMessage';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.TalkClose = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.TalkClose, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.TalkClose.displayName = 'proto.TalkClose';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.TalkRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.TalkRequest.oneofGroups_);
};
goog.inherits(proto.TalkRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.TalkRequest.displayName = 'proto.TalkRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.TalkMessages = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.TalkMessages.repeatedFields_, null);
};
goog.inherits(proto.TalkMessages, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.TalkMessages.displayName = 'proto.TalkMessages';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.TalkMessageConfirmed = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.TalkMessageConfirmed, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.TalkMessageConfirmed.displayName = 'proto.TalkMessageConfirmed';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.TalkNotifyResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.TalkNotifyResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.TalkNotifyResponse.displayName = 'proto.TalkNotifyResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.TalkResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.TalkResponse.oneofGroups_);
};
goog.inherits(proto.TalkResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.TalkResponse.displayName = 'proto.TalkResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ServiceQueryAttachedTalksRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ServiceQueryAttachedTalksRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ServiceQueryAttachedTalksRequest.displayName = 'proto.ServiceQueryAttachedTalksRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ServiceQueryPendingTalksRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ServiceQueryPendingTalksRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ServiceQueryPendingTalksRequest.displayName = 'proto.ServiceQueryPendingTalksRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ServiceReloadTalkRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ServiceReloadTalkRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ServiceReloadTalkRequest.displayName = 'proto.ServiceReloadTalkRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ServicePostMessage = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ServicePostMessage, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ServicePostMessage.displayName = 'proto.ServicePostMessage';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ServiceAttachRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ServiceAttachRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ServiceAttachRequest.displayName = 'proto.ServiceAttachRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ServiceDetachRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ServiceDetachRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ServiceDetachRequest.displayName = 'proto.ServiceDetachRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ServiceRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.ServiceRequest.oneofGroups_);
};
goog.inherits(proto.ServiceRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ServiceRequest.displayName = 'proto.ServiceRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ServicePendingTalksResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.ServicePendingTalksResponse.repeatedFields_, null);
};
goog.inherits(proto.ServicePendingTalksResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ServicePendingTalksResponse.displayName = 'proto.ServicePendingTalksResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ServiceTalkInfoAndMessages = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.ServiceTalkInfoAndMessages.repeatedFields_, null);
};
goog.inherits(proto.ServiceTalkInfoAndMessages, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ServiceTalkInfoAndMessages.displayName = 'proto.ServiceTalkInfoAndMessages';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ServiceAttachedTalksResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.ServiceAttachedTalksResponse.repeatedFields_, null);
};
goog.inherits(proto.ServiceAttachedTalksResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ServiceAttachedTalksResponse.displayName = 'proto.ServiceAttachedTalksResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ServiceAttachTalkResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ServiceAttachTalkResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ServiceAttachTalkResponse.displayName = 'proto.ServiceAttachTalkResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ServiceDetachTalkResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ServiceDetachTalkResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ServiceDetachTalkResponse.displayName = 'proto.ServiceDetachTalkResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ServiceTalkReloadResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ServiceTalkReloadResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ServiceTalkReloadResponse.displayName = 'proto.ServiceTalkReloadResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ServiceTalkMessageResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ServiceTalkMessageResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ServiceTalkMessageResponse.displayName = 'proto.ServiceTalkMessageResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ServiceTalkNotifyResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ServiceTalkNotifyResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ServiceTalkNotifyResponse.displayName = 'proto.ServiceTalkNotifyResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ServiceMessageConfirmed = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ServiceMessageConfirmed, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ServiceMessageConfirmed.displayName = 'proto.ServiceMessageConfirmed';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ServiceTalkClose = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ServiceTalkClose, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ServiceTalkClose.displayName = 'proto.ServiceTalkClose';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ServiceResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.ServiceResponse.oneofGroups_);
};
goog.inherits(proto.ServiceResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ServiceResponse.displayName = 'proto.ServiceResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.CheckTokenRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.CheckTokenRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.CheckTokenRequest.displayName = 'proto.CheckTokenRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.CheckTokenResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.CheckTokenResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.CheckTokenResponse.displayName = 'proto.CheckTokenResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.CreateTokenRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.CreateTokenRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.CreateTokenRequest.displayName = 'proto.CreateTokenRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.CreateTokenResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.CreateTokenResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.CreateTokenResponse.displayName = 'proto.CreateTokenResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.RegisterRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.RegisterRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.RegisterRequest.displayName = 'proto.RegisterRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.RegisterResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.RegisterResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.RegisterResponse.displayName = 'proto.RegisterResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.LoginRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.LoginRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.LoginRequest.displayName = 'proto.LoginRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.LoginResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.LoginResponse.repeatedFields_, null);
};
goog.inherits(proto.LoginResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.LoginResponse.displayName = 'proto.LoginResponse';
}



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.Empty.prototype.toObject = function(opt_includeInstance) {
  return proto.Empty.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.Empty} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Empty.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.Empty}
 */
proto.Empty.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.Empty;
  return proto.Empty.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.Empty} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.Empty}
 */
proto.Empty.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.Empty.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.Empty.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.Empty} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Empty.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.TalkKickOutMessage.prototype.toObject = function(opt_includeInstance) {
  return proto.TalkKickOutMessage.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.TalkKickOutMessage} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkKickOutMessage.toObject = function(includeInstance, msg) {
  var f, obj = {
    code: jspb.Message.getFieldWithDefault(msg, 1, 0),
    message: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.TalkKickOutMessage}
 */
proto.TalkKickOutMessage.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.TalkKickOutMessage;
  return proto.TalkKickOutMessage.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.TalkKickOutMessage} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.TalkKickOutMessage}
 */
proto.TalkKickOutMessage.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setCode(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setMessage(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.TalkKickOutMessage.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.TalkKickOutMessage.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.TalkKickOutMessage} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkKickOutMessage.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCode();
  if (f !== 0) {
    writer.writeInt32(
      1,
      f
    );
  }
  f = message.getMessage();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional int32 code = 1;
 * @return {number}
 */
proto.TalkKickOutMessage.prototype.getCode = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.TalkKickOutMessage} returns this
 */
proto.TalkKickOutMessage.prototype.setCode = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional string message = 2;
 * @return {string}
 */
proto.TalkKickOutMessage.prototype.getMessage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.TalkKickOutMessage} returns this
 */
proto.TalkKickOutMessage.prototype.setMessage = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.QueryTalksRequest.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.QueryTalksRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.QueryTalksRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.QueryTalksRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.QueryTalksRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    statusesList: (f = jspb.Message.getRepeatedField(msg, 1)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.QueryTalksRequest}
 */
proto.QueryTalksRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.QueryTalksRequest;
  return proto.QueryTalksRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.QueryTalksRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.QueryTalksRequest}
 */
proto.QueryTalksRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var values = /** @type {!Array<!proto.TalkStatus>} */ (reader.isDelimited() ? reader.readPackedEnum() : [reader.readEnum()]);
      for (var i = 0; i < values.length; i++) {
        msg.addStatuses(values[i]);
      }
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.QueryTalksRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.QueryTalksRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.QueryTalksRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.QueryTalksRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getStatusesList();
  if (f.length > 0) {
    writer.writePackedEnum(
      1,
      f
    );
  }
};


/**
 * repeated TalkStatus statuses = 1;
 * @return {!Array<!proto.TalkStatus>}
 */
proto.QueryTalksRequest.prototype.getStatusesList = function() {
  return /** @type {!Array<!proto.TalkStatus>} */ (jspb.Message.getRepeatedField(this, 1));
};


/**
 * @param {!Array<!proto.TalkStatus>} value
 * @return {!proto.QueryTalksRequest} returns this
 */
proto.QueryTalksRequest.prototype.setStatusesList = function(value) {
  return jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!proto.TalkStatus} value
 * @param {number=} opt_index
 * @return {!proto.QueryTalksRequest} returns this
 */
proto.QueryTalksRequest.prototype.addStatuses = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.QueryTalksRequest} returns this
 */
proto.QueryTalksRequest.prototype.clearStatusesList = function() {
  return this.setStatusesList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.TalkInfo.prototype.toObject = function(opt_includeInstance) {
  return proto.TalkInfo.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.TalkInfo} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkInfo.toObject = function(includeInstance, msg) {
  var f, obj = {
    talkId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    status: jspb.Message.getFieldWithDefault(msg, 2, 0),
    title: jspb.Message.getFieldWithDefault(msg, 3, ""),
    startedAt: jspb.Message.getFieldWithDefault(msg, 4, 0),
    finishedAt: jspb.Message.getFieldWithDefault(msg, 5, 0),
    customerName: jspb.Message.getFieldWithDefault(msg, 6, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.TalkInfo}
 */
proto.TalkInfo.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.TalkInfo;
  return proto.TalkInfo.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.TalkInfo} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.TalkInfo}
 */
proto.TalkInfo.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setTalkId(value);
      break;
    case 2:
      var value = /** @type {!proto.TalkStatus} */ (reader.readEnum());
      msg.setStatus(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setTitle(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setStartedAt(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setFinishedAt(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setCustomerName(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.TalkInfo.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.TalkInfo.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.TalkInfo} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkInfo.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTalkId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getStatus();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = message.getTitle();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getStartedAt();
  if (f !== 0) {
    writer.writeUint64(
      4,
      f
    );
  }
  f = message.getFinishedAt();
  if (f !== 0) {
    writer.writeUint64(
      5,
      f
    );
  }
  f = message.getCustomerName();
  if (f.length > 0) {
    writer.writeString(
      6,
      f
    );
  }
};


/**
 * optional string talk_id = 1;
 * @return {string}
 */
proto.TalkInfo.prototype.getTalkId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.TalkInfo} returns this
 */
proto.TalkInfo.prototype.setTalkId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional TalkStatus status = 2;
 * @return {!proto.TalkStatus}
 */
proto.TalkInfo.prototype.getStatus = function() {
  return /** @type {!proto.TalkStatus} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {!proto.TalkStatus} value
 * @return {!proto.TalkInfo} returns this
 */
proto.TalkInfo.prototype.setStatus = function(value) {
  return jspb.Message.setProto3EnumField(this, 2, value);
};


/**
 * optional string title = 3;
 * @return {string}
 */
proto.TalkInfo.prototype.getTitle = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.TalkInfo} returns this
 */
proto.TalkInfo.prototype.setTitle = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional uint64 started_at = 4;
 * @return {number}
 */
proto.TalkInfo.prototype.getStartedAt = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.TalkInfo} returns this
 */
proto.TalkInfo.prototype.setStartedAt = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional uint64 finished_at = 5;
 * @return {number}
 */
proto.TalkInfo.prototype.getFinishedAt = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/**
 * @param {number} value
 * @return {!proto.TalkInfo} returns this
 */
proto.TalkInfo.prototype.setFinishedAt = function(value) {
  return jspb.Message.setProto3IntField(this, 5, value);
};


/**
 * optional string customer_name = 6;
 * @return {string}
 */
proto.TalkInfo.prototype.getCustomerName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * @param {string} value
 * @return {!proto.TalkInfo} returns this
 */
proto.TalkInfo.prototype.setCustomerName = function(value) {
  return jspb.Message.setProto3StringField(this, 6, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.QueryTalksResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.QueryTalksResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.QueryTalksResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.QueryTalksResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.QueryTalksResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    talksList: jspb.Message.toObjectList(msg.getTalksList(),
    proto.TalkInfo.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.QueryTalksResponse}
 */
proto.QueryTalksResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.QueryTalksResponse;
  return proto.QueryTalksResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.QueryTalksResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.QueryTalksResponse}
 */
proto.QueryTalksResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.TalkInfo;
      reader.readMessage(value,proto.TalkInfo.deserializeBinaryFromReader);
      msg.addTalks(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.QueryTalksResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.QueryTalksResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.QueryTalksResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.QueryTalksResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTalksList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.TalkInfo.serializeBinaryToWriter
    );
  }
};


/**
 * repeated TalkInfo talks = 1;
 * @return {!Array<!proto.TalkInfo>}
 */
proto.QueryTalksResponse.prototype.getTalksList = function() {
  return /** @type{!Array<!proto.TalkInfo>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.TalkInfo, 1));
};


/**
 * @param {!Array<!proto.TalkInfo>} value
 * @return {!proto.QueryTalksResponse} returns this
*/
proto.QueryTalksResponse.prototype.setTalksList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.TalkInfo=} opt_value
 * @param {number=} opt_index
 * @return {!proto.TalkInfo}
 */
proto.QueryTalksResponse.prototype.addTalks = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.TalkInfo, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.QueryTalksResponse} returns this
 */
proto.QueryTalksResponse.prototype.clearTalksList = function() {
  return this.setTalksList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.TalkCreateRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.TalkCreateRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.TalkCreateRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkCreateRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    title: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.TalkCreateRequest}
 */
proto.TalkCreateRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.TalkCreateRequest;
  return proto.TalkCreateRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.TalkCreateRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.TalkCreateRequest}
 */
proto.TalkCreateRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setTitle(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.TalkCreateRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.TalkCreateRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.TalkCreateRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkCreateRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTitle();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string title = 1;
 * @return {string}
 */
proto.TalkCreateRequest.prototype.getTitle = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.TalkCreateRequest} returns this
 */
proto.TalkCreateRequest.prototype.setTitle = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.TalkOpenRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.TalkOpenRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.TalkOpenRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkOpenRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    talkId: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.TalkOpenRequest}
 */
proto.TalkOpenRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.TalkOpenRequest;
  return proto.TalkOpenRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.TalkOpenRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.TalkOpenRequest}
 */
proto.TalkOpenRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setTalkId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.TalkOpenRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.TalkOpenRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.TalkOpenRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkOpenRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTalkId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string talk_id = 1;
 * @return {string}
 */
proto.TalkOpenRequest.prototype.getTalkId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.TalkOpenRequest} returns this
 */
proto.TalkOpenRequest.prototype.setTalkId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.TalkMessageW.oneofGroups_ = [[20,21]];

/**
 * @enum {number}
 */
proto.TalkMessageW.MessageCase = {
  MESSAGE_NOT_SET: 0,
  TEXT: 20,
  IMAGE: 21
};

/**
 * @return {proto.TalkMessageW.MessageCase}
 */
proto.TalkMessageW.prototype.getMessageCase = function() {
  return /** @type {proto.TalkMessageW.MessageCase} */(jspb.Message.computeOneofCase(this, proto.TalkMessageW.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.TalkMessageW.prototype.toObject = function(opt_includeInstance) {
  return proto.TalkMessageW.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.TalkMessageW} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkMessageW.toObject = function(includeInstance, msg) {
  var f, obj = {
    seqId: jspb.Message.getFieldWithDefault(msg, 1, 0),
    text: jspb.Message.getFieldWithDefault(msg, 20, ""),
    image: msg.getImage_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.TalkMessageW}
 */
proto.TalkMessageW.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.TalkMessageW;
  return proto.TalkMessageW.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.TalkMessageW} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.TalkMessageW}
 */
proto.TalkMessageW.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setSeqId(value);
      break;
    case 20:
      var value = /** @type {string} */ (reader.readString());
      msg.setText(value);
      break;
    case 21:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setImage(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.TalkMessageW.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.TalkMessageW.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.TalkMessageW} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkMessageW.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSeqId();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 20));
  if (f != null) {
    writer.writeString(
      20,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 21));
  if (f != null) {
    writer.writeBytes(
      21,
      f
    );
  }
};


/**
 * optional uint64 seq_id = 1;
 * @return {number}
 */
proto.TalkMessageW.prototype.getSeqId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.TalkMessageW} returns this
 */
proto.TalkMessageW.prototype.setSeqId = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional string text = 20;
 * @return {string}
 */
proto.TalkMessageW.prototype.getText = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 20, ""));
};


/**
 * @param {string} value
 * @return {!proto.TalkMessageW} returns this
 */
proto.TalkMessageW.prototype.setText = function(value) {
  return jspb.Message.setOneofField(this, 20, proto.TalkMessageW.oneofGroups_[0], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.TalkMessageW} returns this
 */
proto.TalkMessageW.prototype.clearText = function() {
  return jspb.Message.setOneofField(this, 20, proto.TalkMessageW.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.TalkMessageW.prototype.hasText = function() {
  return jspb.Message.getField(this, 20) != null;
};


/**
 * optional bytes image = 21;
 * @return {!(string|Uint8Array)}
 */
proto.TalkMessageW.prototype.getImage = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 21, ""));
};


/**
 * optional bytes image = 21;
 * This is a type-conversion wrapper around `getImage()`
 * @return {string}
 */
proto.TalkMessageW.prototype.getImage_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getImage()));
};


/**
 * optional bytes image = 21;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getImage()`
 * @return {!Uint8Array}
 */
proto.TalkMessageW.prototype.getImage_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getImage()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.TalkMessageW} returns this
 */
proto.TalkMessageW.prototype.setImage = function(value) {
  return jspb.Message.setOneofField(this, 21, proto.TalkMessageW.oneofGroups_[0], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.TalkMessageW} returns this
 */
proto.TalkMessageW.prototype.clearImage = function() {
  return jspb.Message.setOneofField(this, 21, proto.TalkMessageW.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.TalkMessageW.prototype.hasImage = function() {
  return jspb.Message.getField(this, 21) != null;
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.TalkMessage.oneofGroups_ = [[20,21]];

/**
 * @enum {number}
 */
proto.TalkMessage.MessageCase = {
  MESSAGE_NOT_SET: 0,
  TEXT: 20,
  IMAGE: 21
};

/**
 * @return {proto.TalkMessage.MessageCase}
 */
proto.TalkMessage.prototype.getMessageCase = function() {
  return /** @type {proto.TalkMessage.MessageCase} */(jspb.Message.computeOneofCase(this, proto.TalkMessage.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.TalkMessage.prototype.toObject = function(opt_includeInstance) {
  return proto.TalkMessage.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.TalkMessage} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkMessage.toObject = function(includeInstance, msg) {
  var f, obj = {
    at: jspb.Message.getFieldWithDefault(msg, 1, 0),
    customerMessage: jspb.Message.getBooleanFieldWithDefault(msg, 2, false),
    user: jspb.Message.getFieldWithDefault(msg, 3, ""),
    text: jspb.Message.getFieldWithDefault(msg, 20, ""),
    image: msg.getImage_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.TalkMessage}
 */
proto.TalkMessage.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.TalkMessage;
  return proto.TalkMessage.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.TalkMessage} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.TalkMessage}
 */
proto.TalkMessage.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setAt(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setCustomerMessage(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setUser(value);
      break;
    case 20:
      var value = /** @type {string} */ (reader.readString());
      msg.setText(value);
      break;
    case 21:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setImage(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.TalkMessage.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.TalkMessage.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.TalkMessage} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkMessage.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAt();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getCustomerMessage();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
  f = message.getUser();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 20));
  if (f != null) {
    writer.writeString(
      20,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 21));
  if (f != null) {
    writer.writeBytes(
      21,
      f
    );
  }
};


/**
 * optional uint64 at = 1;
 * @return {number}
 */
proto.TalkMessage.prototype.getAt = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.TalkMessage} returns this
 */
proto.TalkMessage.prototype.setAt = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional bool customer_message = 2;
 * @return {boolean}
 */
proto.TalkMessage.prototype.getCustomerMessage = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 2, false));
};


/**
 * @param {boolean} value
 * @return {!proto.TalkMessage} returns this
 */
proto.TalkMessage.prototype.setCustomerMessage = function(value) {
  return jspb.Message.setProto3BooleanField(this, 2, value);
};


/**
 * optional string user = 3;
 * @return {string}
 */
proto.TalkMessage.prototype.getUser = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.TalkMessage} returns this
 */
proto.TalkMessage.prototype.setUser = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional string text = 20;
 * @return {string}
 */
proto.TalkMessage.prototype.getText = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 20, ""));
};


/**
 * @param {string} value
 * @return {!proto.TalkMessage} returns this
 */
proto.TalkMessage.prototype.setText = function(value) {
  return jspb.Message.setOneofField(this, 20, proto.TalkMessage.oneofGroups_[0], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.TalkMessage} returns this
 */
proto.TalkMessage.prototype.clearText = function() {
  return jspb.Message.setOneofField(this, 20, proto.TalkMessage.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.TalkMessage.prototype.hasText = function() {
  return jspb.Message.getField(this, 20) != null;
};


/**
 * optional bytes image = 21;
 * @return {!(string|Uint8Array)}
 */
proto.TalkMessage.prototype.getImage = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 21, ""));
};


/**
 * optional bytes image = 21;
 * This is a type-conversion wrapper around `getImage()`
 * @return {string}
 */
proto.TalkMessage.prototype.getImage_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getImage()));
};


/**
 * optional bytes image = 21;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getImage()`
 * @return {!Uint8Array}
 */
proto.TalkMessage.prototype.getImage_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getImage()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.TalkMessage} returns this
 */
proto.TalkMessage.prototype.setImage = function(value) {
  return jspb.Message.setOneofField(this, 21, proto.TalkMessage.oneofGroups_[0], value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.TalkMessage} returns this
 */
proto.TalkMessage.prototype.clearImage = function() {
  return jspb.Message.setOneofField(this, 21, proto.TalkMessage.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.TalkMessage.prototype.hasImage = function() {
  return jspb.Message.getField(this, 21) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.TalkClose.prototype.toObject = function(opt_includeInstance) {
  return proto.TalkClose.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.TalkClose} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkClose.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.TalkClose}
 */
proto.TalkClose.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.TalkClose;
  return proto.TalkClose.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.TalkClose} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.TalkClose}
 */
proto.TalkClose.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.TalkClose.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.TalkClose.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.TalkClose} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkClose.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.TalkRequest.oneofGroups_ = [[1,2,3,4]];

/**
 * @enum {number}
 */
proto.TalkRequest.TalkCase = {
  TALK_NOT_SET: 0,
  CREATE: 1,
  OPEN: 2,
  MESSAGE: 3,
  CLOSE: 4
};

/**
 * @return {proto.TalkRequest.TalkCase}
 */
proto.TalkRequest.prototype.getTalkCase = function() {
  return /** @type {proto.TalkRequest.TalkCase} */(jspb.Message.computeOneofCase(this, proto.TalkRequest.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.TalkRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.TalkRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.TalkRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    create: (f = msg.getCreate()) && proto.TalkCreateRequest.toObject(includeInstance, f),
    open: (f = msg.getOpen()) && proto.TalkOpenRequest.toObject(includeInstance, f),
    message: (f = msg.getMessage()) && proto.TalkMessageW.toObject(includeInstance, f),
    close: (f = msg.getClose()) && proto.TalkClose.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.TalkRequest}
 */
proto.TalkRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.TalkRequest;
  return proto.TalkRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.TalkRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.TalkRequest}
 */
proto.TalkRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.TalkCreateRequest;
      reader.readMessage(value,proto.TalkCreateRequest.deserializeBinaryFromReader);
      msg.setCreate(value);
      break;
    case 2:
      var value = new proto.TalkOpenRequest;
      reader.readMessage(value,proto.TalkOpenRequest.deserializeBinaryFromReader);
      msg.setOpen(value);
      break;
    case 3:
      var value = new proto.TalkMessageW;
      reader.readMessage(value,proto.TalkMessageW.deserializeBinaryFromReader);
      msg.setMessage(value);
      break;
    case 4:
      var value = new proto.TalkClose;
      reader.readMessage(value,proto.TalkClose.deserializeBinaryFromReader);
      msg.setClose(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.TalkRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.TalkRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.TalkRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCreate();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.TalkCreateRequest.serializeBinaryToWriter
    );
  }
  f = message.getOpen();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.TalkOpenRequest.serializeBinaryToWriter
    );
  }
  f = message.getMessage();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.TalkMessageW.serializeBinaryToWriter
    );
  }
  f = message.getClose();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.TalkClose.serializeBinaryToWriter
    );
  }
};


/**
 * optional TalkCreateRequest create = 1;
 * @return {?proto.TalkCreateRequest}
 */
proto.TalkRequest.prototype.getCreate = function() {
  return /** @type{?proto.TalkCreateRequest} */ (
    jspb.Message.getWrapperField(this, proto.TalkCreateRequest, 1));
};


/**
 * @param {?proto.TalkCreateRequest|undefined} value
 * @return {!proto.TalkRequest} returns this
*/
proto.TalkRequest.prototype.setCreate = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.TalkRequest.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.TalkRequest} returns this
 */
proto.TalkRequest.prototype.clearCreate = function() {
  return this.setCreate(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.TalkRequest.prototype.hasCreate = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional TalkOpenRequest open = 2;
 * @return {?proto.TalkOpenRequest}
 */
proto.TalkRequest.prototype.getOpen = function() {
  return /** @type{?proto.TalkOpenRequest} */ (
    jspb.Message.getWrapperField(this, proto.TalkOpenRequest, 2));
};


/**
 * @param {?proto.TalkOpenRequest|undefined} value
 * @return {!proto.TalkRequest} returns this
*/
proto.TalkRequest.prototype.setOpen = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.TalkRequest.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.TalkRequest} returns this
 */
proto.TalkRequest.prototype.clearOpen = function() {
  return this.setOpen(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.TalkRequest.prototype.hasOpen = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional TalkMessageW message = 3;
 * @return {?proto.TalkMessageW}
 */
proto.TalkRequest.prototype.getMessage = function() {
  return /** @type{?proto.TalkMessageW} */ (
    jspb.Message.getWrapperField(this, proto.TalkMessageW, 3));
};


/**
 * @param {?proto.TalkMessageW|undefined} value
 * @return {!proto.TalkRequest} returns this
*/
proto.TalkRequest.prototype.setMessage = function(value) {
  return jspb.Message.setOneofWrapperField(this, 3, proto.TalkRequest.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.TalkRequest} returns this
 */
proto.TalkRequest.prototype.clearMessage = function() {
  return this.setMessage(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.TalkRequest.prototype.hasMessage = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional TalkClose close = 4;
 * @return {?proto.TalkClose}
 */
proto.TalkRequest.prototype.getClose = function() {
  return /** @type{?proto.TalkClose} */ (
    jspb.Message.getWrapperField(this, proto.TalkClose, 4));
};


/**
 * @param {?proto.TalkClose|undefined} value
 * @return {!proto.TalkRequest} returns this
*/
proto.TalkRequest.prototype.setClose = function(value) {
  return jspb.Message.setOneofWrapperField(this, 4, proto.TalkRequest.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.TalkRequest} returns this
 */
proto.TalkRequest.prototype.clearClose = function() {
  return this.setClose(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.TalkRequest.prototype.hasClose = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.TalkMessages.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.TalkMessages.prototype.toObject = function(opt_includeInstance) {
  return proto.TalkMessages.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.TalkMessages} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkMessages.toObject = function(includeInstance, msg) {
  var f, obj = {
    talkId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    messagesList: jspb.Message.toObjectList(msg.getMessagesList(),
    proto.TalkMessage.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.TalkMessages}
 */
proto.TalkMessages.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.TalkMessages;
  return proto.TalkMessages.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.TalkMessages} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.TalkMessages}
 */
proto.TalkMessages.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setTalkId(value);
      break;
    case 2:
      var value = new proto.TalkMessage;
      reader.readMessage(value,proto.TalkMessage.deserializeBinaryFromReader);
      msg.addMessages(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.TalkMessages.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.TalkMessages.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.TalkMessages} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkMessages.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTalkId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getMessagesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.TalkMessage.serializeBinaryToWriter
    );
  }
};


/**
 * optional string talk_id = 1;
 * @return {string}
 */
proto.TalkMessages.prototype.getTalkId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.TalkMessages} returns this
 */
proto.TalkMessages.prototype.setTalkId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * repeated TalkMessage messages = 2;
 * @return {!Array<!proto.TalkMessage>}
 */
proto.TalkMessages.prototype.getMessagesList = function() {
  return /** @type{!Array<!proto.TalkMessage>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.TalkMessage, 2));
};


/**
 * @param {!Array<!proto.TalkMessage>} value
 * @return {!proto.TalkMessages} returns this
*/
proto.TalkMessages.prototype.setMessagesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.TalkMessage=} opt_value
 * @param {number=} opt_index
 * @return {!proto.TalkMessage}
 */
proto.TalkMessages.prototype.addMessages = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.TalkMessage, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.TalkMessages} returns this
 */
proto.TalkMessages.prototype.clearMessagesList = function() {
  return this.setMessagesList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.TalkMessageConfirmed.prototype.toObject = function(opt_includeInstance) {
  return proto.TalkMessageConfirmed.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.TalkMessageConfirmed} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkMessageConfirmed.toObject = function(includeInstance, msg) {
  var f, obj = {
    seqId: jspb.Message.getFieldWithDefault(msg, 1, 0),
    at: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.TalkMessageConfirmed}
 */
proto.TalkMessageConfirmed.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.TalkMessageConfirmed;
  return proto.TalkMessageConfirmed.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.TalkMessageConfirmed} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.TalkMessageConfirmed}
 */
proto.TalkMessageConfirmed.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setSeqId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setAt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.TalkMessageConfirmed.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.TalkMessageConfirmed.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.TalkMessageConfirmed} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkMessageConfirmed.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSeqId();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getAt();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
};


/**
 * optional uint64 seq_id = 1;
 * @return {number}
 */
proto.TalkMessageConfirmed.prototype.getSeqId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.TalkMessageConfirmed} returns this
 */
proto.TalkMessageConfirmed.prototype.setSeqId = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint64 at = 2;
 * @return {number}
 */
proto.TalkMessageConfirmed.prototype.getAt = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.TalkMessageConfirmed} returns this
 */
proto.TalkMessageConfirmed.prototype.setAt = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.TalkNotifyResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.TalkNotifyResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.TalkNotifyResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkNotifyResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    msg: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.TalkNotifyResponse}
 */
proto.TalkNotifyResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.TalkNotifyResponse;
  return proto.TalkNotifyResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.TalkNotifyResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.TalkNotifyResponse}
 */
proto.TalkNotifyResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMsg(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.TalkNotifyResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.TalkNotifyResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.TalkNotifyResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkNotifyResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMsg();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string msg = 1;
 * @return {string}
 */
proto.TalkNotifyResponse.prototype.getMsg = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.TalkNotifyResponse} returns this
 */
proto.TalkNotifyResponse.prototype.setMsg = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.TalkResponse.oneofGroups_ = [[1,2,3,4,5,6]];

/**
 * @enum {number}
 */
proto.TalkResponse.TalkCase = {
  TALK_NOT_SET: 0,
  KICK_OUT: 1,
  MESSAGES: 2,
  MESSAGE: 3,
  MESSAGE_CONFIRMED: 4,
  CLOSE: 5,
  NOTIFY: 6
};

/**
 * @return {proto.TalkResponse.TalkCase}
 */
proto.TalkResponse.prototype.getTalkCase = function() {
  return /** @type {proto.TalkResponse.TalkCase} */(jspb.Message.computeOneofCase(this, proto.TalkResponse.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.TalkResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.TalkResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.TalkResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    kickOut: (f = msg.getKickOut()) && proto.TalkKickOutMessage.toObject(includeInstance, f),
    messages: (f = msg.getMessages()) && proto.TalkMessages.toObject(includeInstance, f),
    message: (f = msg.getMessage()) && proto.TalkMessage.toObject(includeInstance, f),
    messageConfirmed: (f = msg.getMessageConfirmed()) && proto.TalkMessageConfirmed.toObject(includeInstance, f),
    close: (f = msg.getClose()) && proto.TalkClose.toObject(includeInstance, f),
    notify: (f = msg.getNotify()) && proto.TalkNotifyResponse.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.TalkResponse}
 */
proto.TalkResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.TalkResponse;
  return proto.TalkResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.TalkResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.TalkResponse}
 */
proto.TalkResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.TalkKickOutMessage;
      reader.readMessage(value,proto.TalkKickOutMessage.deserializeBinaryFromReader);
      msg.setKickOut(value);
      break;
    case 2:
      var value = new proto.TalkMessages;
      reader.readMessage(value,proto.TalkMessages.deserializeBinaryFromReader);
      msg.setMessages(value);
      break;
    case 3:
      var value = new proto.TalkMessage;
      reader.readMessage(value,proto.TalkMessage.deserializeBinaryFromReader);
      msg.setMessage(value);
      break;
    case 4:
      var value = new proto.TalkMessageConfirmed;
      reader.readMessage(value,proto.TalkMessageConfirmed.deserializeBinaryFromReader);
      msg.setMessageConfirmed(value);
      break;
    case 5:
      var value = new proto.TalkClose;
      reader.readMessage(value,proto.TalkClose.deserializeBinaryFromReader);
      msg.setClose(value);
      break;
    case 6:
      var value = new proto.TalkNotifyResponse;
      reader.readMessage(value,proto.TalkNotifyResponse.deserializeBinaryFromReader);
      msg.setNotify(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.TalkResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.TalkResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.TalkResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TalkResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getKickOut();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.TalkKickOutMessage.serializeBinaryToWriter
    );
  }
  f = message.getMessages();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.TalkMessages.serializeBinaryToWriter
    );
  }
  f = message.getMessage();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.TalkMessage.serializeBinaryToWriter
    );
  }
  f = message.getMessageConfirmed();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.TalkMessageConfirmed.serializeBinaryToWriter
    );
  }
  f = message.getClose();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.TalkClose.serializeBinaryToWriter
    );
  }
  f = message.getNotify();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.TalkNotifyResponse.serializeBinaryToWriter
    );
  }
};


/**
 * optional TalkKickOutMessage kick_out = 1;
 * @return {?proto.TalkKickOutMessage}
 */
proto.TalkResponse.prototype.getKickOut = function() {
  return /** @type{?proto.TalkKickOutMessage} */ (
    jspb.Message.getWrapperField(this, proto.TalkKickOutMessage, 1));
};


/**
 * @param {?proto.TalkKickOutMessage|undefined} value
 * @return {!proto.TalkResponse} returns this
*/
proto.TalkResponse.prototype.setKickOut = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.TalkResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.TalkResponse} returns this
 */
proto.TalkResponse.prototype.clearKickOut = function() {
  return this.setKickOut(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.TalkResponse.prototype.hasKickOut = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional TalkMessages messages = 2;
 * @return {?proto.TalkMessages}
 */
proto.TalkResponse.prototype.getMessages = function() {
  return /** @type{?proto.TalkMessages} */ (
    jspb.Message.getWrapperField(this, proto.TalkMessages, 2));
};


/**
 * @param {?proto.TalkMessages|undefined} value
 * @return {!proto.TalkResponse} returns this
*/
proto.TalkResponse.prototype.setMessages = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.TalkResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.TalkResponse} returns this
 */
proto.TalkResponse.prototype.clearMessages = function() {
  return this.setMessages(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.TalkResponse.prototype.hasMessages = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional TalkMessage message = 3;
 * @return {?proto.TalkMessage}
 */
proto.TalkResponse.prototype.getMessage = function() {
  return /** @type{?proto.TalkMessage} */ (
    jspb.Message.getWrapperField(this, proto.TalkMessage, 3));
};


/**
 * @param {?proto.TalkMessage|undefined} value
 * @return {!proto.TalkResponse} returns this
*/
proto.TalkResponse.prototype.setMessage = function(value) {
  return jspb.Message.setOneofWrapperField(this, 3, proto.TalkResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.TalkResponse} returns this
 */
proto.TalkResponse.prototype.clearMessage = function() {
  return this.setMessage(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.TalkResponse.prototype.hasMessage = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional TalkMessageConfirmed message_confirmed = 4;
 * @return {?proto.TalkMessageConfirmed}
 */
proto.TalkResponse.prototype.getMessageConfirmed = function() {
  return /** @type{?proto.TalkMessageConfirmed} */ (
    jspb.Message.getWrapperField(this, proto.TalkMessageConfirmed, 4));
};


/**
 * @param {?proto.TalkMessageConfirmed|undefined} value
 * @return {!proto.TalkResponse} returns this
*/
proto.TalkResponse.prototype.setMessageConfirmed = function(value) {
  return jspb.Message.setOneofWrapperField(this, 4, proto.TalkResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.TalkResponse} returns this
 */
proto.TalkResponse.prototype.clearMessageConfirmed = function() {
  return this.setMessageConfirmed(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.TalkResponse.prototype.hasMessageConfirmed = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional TalkClose close = 5;
 * @return {?proto.TalkClose}
 */
proto.TalkResponse.prototype.getClose = function() {
  return /** @type{?proto.TalkClose} */ (
    jspb.Message.getWrapperField(this, proto.TalkClose, 5));
};


/**
 * @param {?proto.TalkClose|undefined} value
 * @return {!proto.TalkResponse} returns this
*/
proto.TalkResponse.prototype.setClose = function(value) {
  return jspb.Message.setOneofWrapperField(this, 5, proto.TalkResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.TalkResponse} returns this
 */
proto.TalkResponse.prototype.clearClose = function() {
  return this.setClose(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.TalkResponse.prototype.hasClose = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional TalkNotifyResponse notify = 6;
 * @return {?proto.TalkNotifyResponse}
 */
proto.TalkResponse.prototype.getNotify = function() {
  return /** @type{?proto.TalkNotifyResponse} */ (
    jspb.Message.getWrapperField(this, proto.TalkNotifyResponse, 6));
};


/**
 * @param {?proto.TalkNotifyResponse|undefined} value
 * @return {!proto.TalkResponse} returns this
*/
proto.TalkResponse.prototype.setNotify = function(value) {
  return jspb.Message.setOneofWrapperField(this, 6, proto.TalkResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.TalkResponse} returns this
 */
proto.TalkResponse.prototype.clearNotify = function() {
  return this.setNotify(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.TalkResponse.prototype.hasNotify = function() {
  return jspb.Message.getField(this, 6) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ServiceQueryAttachedTalksRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.ServiceQueryAttachedTalksRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ServiceQueryAttachedTalksRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceQueryAttachedTalksRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ServiceQueryAttachedTalksRequest}
 */
proto.ServiceQueryAttachedTalksRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ServiceQueryAttachedTalksRequest;
  return proto.ServiceQueryAttachedTalksRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ServiceQueryAttachedTalksRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ServiceQueryAttachedTalksRequest}
 */
proto.ServiceQueryAttachedTalksRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ServiceQueryAttachedTalksRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ServiceQueryAttachedTalksRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ServiceQueryAttachedTalksRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceQueryAttachedTalksRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ServiceQueryPendingTalksRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.ServiceQueryPendingTalksRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ServiceQueryPendingTalksRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceQueryPendingTalksRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ServiceQueryPendingTalksRequest}
 */
proto.ServiceQueryPendingTalksRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ServiceQueryPendingTalksRequest;
  return proto.ServiceQueryPendingTalksRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ServiceQueryPendingTalksRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ServiceQueryPendingTalksRequest}
 */
proto.ServiceQueryPendingTalksRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ServiceQueryPendingTalksRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ServiceQueryPendingTalksRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ServiceQueryPendingTalksRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceQueryPendingTalksRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ServiceReloadTalkRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.ServiceReloadTalkRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ServiceReloadTalkRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceReloadTalkRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    talkId: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ServiceReloadTalkRequest}
 */
proto.ServiceReloadTalkRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ServiceReloadTalkRequest;
  return proto.ServiceReloadTalkRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ServiceReloadTalkRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ServiceReloadTalkRequest}
 */
proto.ServiceReloadTalkRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setTalkId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ServiceReloadTalkRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ServiceReloadTalkRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ServiceReloadTalkRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceReloadTalkRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTalkId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string talk_id = 1;
 * @return {string}
 */
proto.ServiceReloadTalkRequest.prototype.getTalkId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.ServiceReloadTalkRequest} returns this
 */
proto.ServiceReloadTalkRequest.prototype.setTalkId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ServicePostMessage.prototype.toObject = function(opt_includeInstance) {
  return proto.ServicePostMessage.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ServicePostMessage} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServicePostMessage.toObject = function(includeInstance, msg) {
  var f, obj = {
    talkId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    message: (f = msg.getMessage()) && proto.TalkMessageW.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ServicePostMessage}
 */
proto.ServicePostMessage.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ServicePostMessage;
  return proto.ServicePostMessage.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ServicePostMessage} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ServicePostMessage}
 */
proto.ServicePostMessage.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setTalkId(value);
      break;
    case 2:
      var value = new proto.TalkMessageW;
      reader.readMessage(value,proto.TalkMessageW.deserializeBinaryFromReader);
      msg.setMessage(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ServicePostMessage.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ServicePostMessage.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ServicePostMessage} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServicePostMessage.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTalkId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getMessage();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.TalkMessageW.serializeBinaryToWriter
    );
  }
};


/**
 * optional string talk_id = 1;
 * @return {string}
 */
proto.ServicePostMessage.prototype.getTalkId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.ServicePostMessage} returns this
 */
proto.ServicePostMessage.prototype.setTalkId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional TalkMessageW message = 2;
 * @return {?proto.TalkMessageW}
 */
proto.ServicePostMessage.prototype.getMessage = function() {
  return /** @type{?proto.TalkMessageW} */ (
    jspb.Message.getWrapperField(this, proto.TalkMessageW, 2));
};


/**
 * @param {?proto.TalkMessageW|undefined} value
 * @return {!proto.ServicePostMessage} returns this
*/
proto.ServicePostMessage.prototype.setMessage = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ServicePostMessage} returns this
 */
proto.ServicePostMessage.prototype.clearMessage = function() {
  return this.setMessage(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ServicePostMessage.prototype.hasMessage = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ServiceAttachRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.ServiceAttachRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ServiceAttachRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceAttachRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    talkId: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ServiceAttachRequest}
 */
proto.ServiceAttachRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ServiceAttachRequest;
  return proto.ServiceAttachRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ServiceAttachRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ServiceAttachRequest}
 */
proto.ServiceAttachRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setTalkId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ServiceAttachRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ServiceAttachRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ServiceAttachRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceAttachRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTalkId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string talk_id = 1;
 * @return {string}
 */
proto.ServiceAttachRequest.prototype.getTalkId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.ServiceAttachRequest} returns this
 */
proto.ServiceAttachRequest.prototype.setTalkId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ServiceDetachRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.ServiceDetachRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ServiceDetachRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceDetachRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    talkId: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ServiceDetachRequest}
 */
proto.ServiceDetachRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ServiceDetachRequest;
  return proto.ServiceDetachRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ServiceDetachRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ServiceDetachRequest}
 */
proto.ServiceDetachRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setTalkId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ServiceDetachRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ServiceDetachRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ServiceDetachRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceDetachRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTalkId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string talk_id = 1;
 * @return {string}
 */
proto.ServiceDetachRequest.prototype.getTalkId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.ServiceDetachRequest} returns this
 */
proto.ServiceDetachRequest.prototype.setTalkId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.ServiceRequest.oneofGroups_ = [[1,2,3,4,5,6]];

/**
 * @enum {number}
 */
proto.ServiceRequest.RequestCase = {
  REQUEST_NOT_SET: 0,
  ATTACHED_TALKS: 1,
  PENDING_TALKS: 2,
  RELOAD: 3,
  MESSAGE: 4,
  ATTACH: 5,
  DETACH: 6
};

/**
 * @return {proto.ServiceRequest.RequestCase}
 */
proto.ServiceRequest.prototype.getRequestCase = function() {
  return /** @type {proto.ServiceRequest.RequestCase} */(jspb.Message.computeOneofCase(this, proto.ServiceRequest.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ServiceRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.ServiceRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ServiceRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    attachedTalks: (f = msg.getAttachedTalks()) && proto.ServiceQueryAttachedTalksRequest.toObject(includeInstance, f),
    pendingTalks: (f = msg.getPendingTalks()) && proto.ServiceQueryPendingTalksRequest.toObject(includeInstance, f),
    reload: (f = msg.getReload()) && proto.ServiceReloadTalkRequest.toObject(includeInstance, f),
    message: (f = msg.getMessage()) && proto.ServicePostMessage.toObject(includeInstance, f),
    attach: (f = msg.getAttach()) && proto.ServiceAttachRequest.toObject(includeInstance, f),
    detach: (f = msg.getDetach()) && proto.ServiceDetachRequest.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ServiceRequest}
 */
proto.ServiceRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ServiceRequest;
  return proto.ServiceRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ServiceRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ServiceRequest}
 */
proto.ServiceRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.ServiceQueryAttachedTalksRequest;
      reader.readMessage(value,proto.ServiceQueryAttachedTalksRequest.deserializeBinaryFromReader);
      msg.setAttachedTalks(value);
      break;
    case 2:
      var value = new proto.ServiceQueryPendingTalksRequest;
      reader.readMessage(value,proto.ServiceQueryPendingTalksRequest.deserializeBinaryFromReader);
      msg.setPendingTalks(value);
      break;
    case 3:
      var value = new proto.ServiceReloadTalkRequest;
      reader.readMessage(value,proto.ServiceReloadTalkRequest.deserializeBinaryFromReader);
      msg.setReload(value);
      break;
    case 4:
      var value = new proto.ServicePostMessage;
      reader.readMessage(value,proto.ServicePostMessage.deserializeBinaryFromReader);
      msg.setMessage(value);
      break;
    case 5:
      var value = new proto.ServiceAttachRequest;
      reader.readMessage(value,proto.ServiceAttachRequest.deserializeBinaryFromReader);
      msg.setAttach(value);
      break;
    case 6:
      var value = new proto.ServiceDetachRequest;
      reader.readMessage(value,proto.ServiceDetachRequest.deserializeBinaryFromReader);
      msg.setDetach(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ServiceRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ServiceRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ServiceRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAttachedTalks();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.ServiceQueryAttachedTalksRequest.serializeBinaryToWriter
    );
  }
  f = message.getPendingTalks();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.ServiceQueryPendingTalksRequest.serializeBinaryToWriter
    );
  }
  f = message.getReload();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.ServiceReloadTalkRequest.serializeBinaryToWriter
    );
  }
  f = message.getMessage();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.ServicePostMessage.serializeBinaryToWriter
    );
  }
  f = message.getAttach();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.ServiceAttachRequest.serializeBinaryToWriter
    );
  }
  f = message.getDetach();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.ServiceDetachRequest.serializeBinaryToWriter
    );
  }
};


/**
 * optional ServiceQueryAttachedTalksRequest attached_talks = 1;
 * @return {?proto.ServiceQueryAttachedTalksRequest}
 */
proto.ServiceRequest.prototype.getAttachedTalks = function() {
  return /** @type{?proto.ServiceQueryAttachedTalksRequest} */ (
    jspb.Message.getWrapperField(this, proto.ServiceQueryAttachedTalksRequest, 1));
};


/**
 * @param {?proto.ServiceQueryAttachedTalksRequest|undefined} value
 * @return {!proto.ServiceRequest} returns this
*/
proto.ServiceRequest.prototype.setAttachedTalks = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.ServiceRequest.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ServiceRequest} returns this
 */
proto.ServiceRequest.prototype.clearAttachedTalks = function() {
  return this.setAttachedTalks(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ServiceRequest.prototype.hasAttachedTalks = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ServiceQueryPendingTalksRequest pending_talks = 2;
 * @return {?proto.ServiceQueryPendingTalksRequest}
 */
proto.ServiceRequest.prototype.getPendingTalks = function() {
  return /** @type{?proto.ServiceQueryPendingTalksRequest} */ (
    jspb.Message.getWrapperField(this, proto.ServiceQueryPendingTalksRequest, 2));
};


/**
 * @param {?proto.ServiceQueryPendingTalksRequest|undefined} value
 * @return {!proto.ServiceRequest} returns this
*/
proto.ServiceRequest.prototype.setPendingTalks = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.ServiceRequest.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ServiceRequest} returns this
 */
proto.ServiceRequest.prototype.clearPendingTalks = function() {
  return this.setPendingTalks(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ServiceRequest.prototype.hasPendingTalks = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional ServiceReloadTalkRequest reload = 3;
 * @return {?proto.ServiceReloadTalkRequest}
 */
proto.ServiceRequest.prototype.getReload = function() {
  return /** @type{?proto.ServiceReloadTalkRequest} */ (
    jspb.Message.getWrapperField(this, proto.ServiceReloadTalkRequest, 3));
};


/**
 * @param {?proto.ServiceReloadTalkRequest|undefined} value
 * @return {!proto.ServiceRequest} returns this
*/
proto.ServiceRequest.prototype.setReload = function(value) {
  return jspb.Message.setOneofWrapperField(this, 3, proto.ServiceRequest.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ServiceRequest} returns this
 */
proto.ServiceRequest.prototype.clearReload = function() {
  return this.setReload(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ServiceRequest.prototype.hasReload = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional ServicePostMessage message = 4;
 * @return {?proto.ServicePostMessage}
 */
proto.ServiceRequest.prototype.getMessage = function() {
  return /** @type{?proto.ServicePostMessage} */ (
    jspb.Message.getWrapperField(this, proto.ServicePostMessage, 4));
};


/**
 * @param {?proto.ServicePostMessage|undefined} value
 * @return {!proto.ServiceRequest} returns this
*/
proto.ServiceRequest.prototype.setMessage = function(value) {
  return jspb.Message.setOneofWrapperField(this, 4, proto.ServiceRequest.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ServiceRequest} returns this
 */
proto.ServiceRequest.prototype.clearMessage = function() {
  return this.setMessage(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ServiceRequest.prototype.hasMessage = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional ServiceAttachRequest attach = 5;
 * @return {?proto.ServiceAttachRequest}
 */
proto.ServiceRequest.prototype.getAttach = function() {
  return /** @type{?proto.ServiceAttachRequest} */ (
    jspb.Message.getWrapperField(this, proto.ServiceAttachRequest, 5));
};


/**
 * @param {?proto.ServiceAttachRequest|undefined} value
 * @return {!proto.ServiceRequest} returns this
*/
proto.ServiceRequest.prototype.setAttach = function(value) {
  return jspb.Message.setOneofWrapperField(this, 5, proto.ServiceRequest.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ServiceRequest} returns this
 */
proto.ServiceRequest.prototype.clearAttach = function() {
  return this.setAttach(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ServiceRequest.prototype.hasAttach = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional ServiceDetachRequest detach = 6;
 * @return {?proto.ServiceDetachRequest}
 */
proto.ServiceRequest.prototype.getDetach = function() {
  return /** @type{?proto.ServiceDetachRequest} */ (
    jspb.Message.getWrapperField(this, proto.ServiceDetachRequest, 6));
};


/**
 * @param {?proto.ServiceDetachRequest|undefined} value
 * @return {!proto.ServiceRequest} returns this
*/
proto.ServiceRequest.prototype.setDetach = function(value) {
  return jspb.Message.setOneofWrapperField(this, 6, proto.ServiceRequest.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ServiceRequest} returns this
 */
proto.ServiceRequest.prototype.clearDetach = function() {
  return this.setDetach(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ServiceRequest.prototype.hasDetach = function() {
  return jspb.Message.getField(this, 6) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.ServicePendingTalksResponse.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ServicePendingTalksResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.ServicePendingTalksResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ServicePendingTalksResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServicePendingTalksResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    talksList: jspb.Message.toObjectList(msg.getTalksList(),
    proto.TalkInfo.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ServicePendingTalksResponse}
 */
proto.ServicePendingTalksResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ServicePendingTalksResponse;
  return proto.ServicePendingTalksResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ServicePendingTalksResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ServicePendingTalksResponse}
 */
proto.ServicePendingTalksResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 2:
      var value = new proto.TalkInfo;
      reader.readMessage(value,proto.TalkInfo.deserializeBinaryFromReader);
      msg.addTalks(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ServicePendingTalksResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ServicePendingTalksResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ServicePendingTalksResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServicePendingTalksResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTalksList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.TalkInfo.serializeBinaryToWriter
    );
  }
};


/**
 * repeated TalkInfo talks = 2;
 * @return {!Array<!proto.TalkInfo>}
 */
proto.ServicePendingTalksResponse.prototype.getTalksList = function() {
  return /** @type{!Array<!proto.TalkInfo>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.TalkInfo, 2));
};


/**
 * @param {!Array<!proto.TalkInfo>} value
 * @return {!proto.ServicePendingTalksResponse} returns this
*/
proto.ServicePendingTalksResponse.prototype.setTalksList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.TalkInfo=} opt_value
 * @param {number=} opt_index
 * @return {!proto.TalkInfo}
 */
proto.ServicePendingTalksResponse.prototype.addTalks = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.TalkInfo, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.ServicePendingTalksResponse} returns this
 */
proto.ServicePendingTalksResponse.prototype.clearTalksList = function() {
  return this.setTalksList([]);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.ServiceTalkInfoAndMessages.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ServiceTalkInfoAndMessages.prototype.toObject = function(opt_includeInstance) {
  return proto.ServiceTalkInfoAndMessages.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ServiceTalkInfoAndMessages} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceTalkInfoAndMessages.toObject = function(includeInstance, msg) {
  var f, obj = {
    talkInfo: (f = msg.getTalkInfo()) && proto.TalkInfo.toObject(includeInstance, f),
    messagesList: jspb.Message.toObjectList(msg.getMessagesList(),
    proto.TalkMessage.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ServiceTalkInfoAndMessages}
 */
proto.ServiceTalkInfoAndMessages.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ServiceTalkInfoAndMessages;
  return proto.ServiceTalkInfoAndMessages.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ServiceTalkInfoAndMessages} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ServiceTalkInfoAndMessages}
 */
proto.ServiceTalkInfoAndMessages.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.TalkInfo;
      reader.readMessage(value,proto.TalkInfo.deserializeBinaryFromReader);
      msg.setTalkInfo(value);
      break;
    case 2:
      var value = new proto.TalkMessage;
      reader.readMessage(value,proto.TalkMessage.deserializeBinaryFromReader);
      msg.addMessages(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ServiceTalkInfoAndMessages.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ServiceTalkInfoAndMessages.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ServiceTalkInfoAndMessages} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceTalkInfoAndMessages.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTalkInfo();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.TalkInfo.serializeBinaryToWriter
    );
  }
  f = message.getMessagesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.TalkMessage.serializeBinaryToWriter
    );
  }
};


/**
 * optional TalkInfo talk_info = 1;
 * @return {?proto.TalkInfo}
 */
proto.ServiceTalkInfoAndMessages.prototype.getTalkInfo = function() {
  return /** @type{?proto.TalkInfo} */ (
    jspb.Message.getWrapperField(this, proto.TalkInfo, 1));
};


/**
 * @param {?proto.TalkInfo|undefined} value
 * @return {!proto.ServiceTalkInfoAndMessages} returns this
*/
proto.ServiceTalkInfoAndMessages.prototype.setTalkInfo = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ServiceTalkInfoAndMessages} returns this
 */
proto.ServiceTalkInfoAndMessages.prototype.clearTalkInfo = function() {
  return this.setTalkInfo(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ServiceTalkInfoAndMessages.prototype.hasTalkInfo = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated TalkMessage messages = 2;
 * @return {!Array<!proto.TalkMessage>}
 */
proto.ServiceTalkInfoAndMessages.prototype.getMessagesList = function() {
  return /** @type{!Array<!proto.TalkMessage>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.TalkMessage, 2));
};


/**
 * @param {!Array<!proto.TalkMessage>} value
 * @return {!proto.ServiceTalkInfoAndMessages} returns this
*/
proto.ServiceTalkInfoAndMessages.prototype.setMessagesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.TalkMessage=} opt_value
 * @param {number=} opt_index
 * @return {!proto.TalkMessage}
 */
proto.ServiceTalkInfoAndMessages.prototype.addMessages = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.TalkMessage, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.ServiceTalkInfoAndMessages} returns this
 */
proto.ServiceTalkInfoAndMessages.prototype.clearMessagesList = function() {
  return this.setMessagesList([]);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.ServiceAttachedTalksResponse.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ServiceAttachedTalksResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.ServiceAttachedTalksResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ServiceAttachedTalksResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceAttachedTalksResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    talksList: jspb.Message.toObjectList(msg.getTalksList(),
    proto.ServiceTalkInfoAndMessages.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ServiceAttachedTalksResponse}
 */
proto.ServiceAttachedTalksResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ServiceAttachedTalksResponse;
  return proto.ServiceAttachedTalksResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ServiceAttachedTalksResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ServiceAttachedTalksResponse}
 */
proto.ServiceAttachedTalksResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 2:
      var value = new proto.ServiceTalkInfoAndMessages;
      reader.readMessage(value,proto.ServiceTalkInfoAndMessages.deserializeBinaryFromReader);
      msg.addTalks(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ServiceAttachedTalksResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ServiceAttachedTalksResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ServiceAttachedTalksResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceAttachedTalksResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTalksList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.ServiceTalkInfoAndMessages.serializeBinaryToWriter
    );
  }
};


/**
 * repeated ServiceTalkInfoAndMessages talks = 2;
 * @return {!Array<!proto.ServiceTalkInfoAndMessages>}
 */
proto.ServiceAttachedTalksResponse.prototype.getTalksList = function() {
  return /** @type{!Array<!proto.ServiceTalkInfoAndMessages>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.ServiceTalkInfoAndMessages, 2));
};


/**
 * @param {!Array<!proto.ServiceTalkInfoAndMessages>} value
 * @return {!proto.ServiceAttachedTalksResponse} returns this
*/
proto.ServiceAttachedTalksResponse.prototype.setTalksList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.ServiceTalkInfoAndMessages=} opt_value
 * @param {number=} opt_index
 * @return {!proto.ServiceTalkInfoAndMessages}
 */
proto.ServiceAttachedTalksResponse.prototype.addTalks = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.ServiceTalkInfoAndMessages, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.ServiceAttachedTalksResponse} returns this
 */
proto.ServiceAttachedTalksResponse.prototype.clearTalksList = function() {
  return this.setTalksList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ServiceAttachTalkResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.ServiceAttachTalkResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ServiceAttachTalkResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceAttachTalkResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    talk: (f = msg.getTalk()) && proto.TalkInfo.toObject(includeInstance, f),
    attachedServiceId: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ServiceAttachTalkResponse}
 */
proto.ServiceAttachTalkResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ServiceAttachTalkResponse;
  return proto.ServiceAttachTalkResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ServiceAttachTalkResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ServiceAttachTalkResponse}
 */
proto.ServiceAttachTalkResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.TalkInfo;
      reader.readMessage(value,proto.TalkInfo.deserializeBinaryFromReader);
      msg.setTalk(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setAttachedServiceId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ServiceAttachTalkResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ServiceAttachTalkResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ServiceAttachTalkResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceAttachTalkResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTalk();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.TalkInfo.serializeBinaryToWriter
    );
  }
  f = message.getAttachedServiceId();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
};


/**
 * optional TalkInfo talk = 1;
 * @return {?proto.TalkInfo}
 */
proto.ServiceAttachTalkResponse.prototype.getTalk = function() {
  return /** @type{?proto.TalkInfo} */ (
    jspb.Message.getWrapperField(this, proto.TalkInfo, 1));
};


/**
 * @param {?proto.TalkInfo|undefined} value
 * @return {!proto.ServiceAttachTalkResponse} returns this
*/
proto.ServiceAttachTalkResponse.prototype.setTalk = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ServiceAttachTalkResponse} returns this
 */
proto.ServiceAttachTalkResponse.prototype.clearTalk = function() {
  return this.setTalk(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ServiceAttachTalkResponse.prototype.hasTalk = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint64 attached_service_id = 2;
 * @return {number}
 */
proto.ServiceAttachTalkResponse.prototype.getAttachedServiceId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.ServiceAttachTalkResponse} returns this
 */
proto.ServiceAttachTalkResponse.prototype.setAttachedServiceId = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ServiceDetachTalkResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.ServiceDetachTalkResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ServiceDetachTalkResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceDetachTalkResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    talk: (f = msg.getTalk()) && proto.TalkInfo.toObject(includeInstance, f),
    detachedServiceId: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ServiceDetachTalkResponse}
 */
proto.ServiceDetachTalkResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ServiceDetachTalkResponse;
  return proto.ServiceDetachTalkResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ServiceDetachTalkResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ServiceDetachTalkResponse}
 */
proto.ServiceDetachTalkResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.TalkInfo;
      reader.readMessage(value,proto.TalkInfo.deserializeBinaryFromReader);
      msg.setTalk(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setDetachedServiceId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ServiceDetachTalkResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ServiceDetachTalkResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ServiceDetachTalkResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceDetachTalkResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTalk();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.TalkInfo.serializeBinaryToWriter
    );
  }
  f = message.getDetachedServiceId();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
};


/**
 * optional TalkInfo talk = 1;
 * @return {?proto.TalkInfo}
 */
proto.ServiceDetachTalkResponse.prototype.getTalk = function() {
  return /** @type{?proto.TalkInfo} */ (
    jspb.Message.getWrapperField(this, proto.TalkInfo, 1));
};


/**
 * @param {?proto.TalkInfo|undefined} value
 * @return {!proto.ServiceDetachTalkResponse} returns this
*/
proto.ServiceDetachTalkResponse.prototype.setTalk = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ServiceDetachTalkResponse} returns this
 */
proto.ServiceDetachTalkResponse.prototype.clearTalk = function() {
  return this.setTalk(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ServiceDetachTalkResponse.prototype.hasTalk = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint64 detached_service_id = 2;
 * @return {number}
 */
proto.ServiceDetachTalkResponse.prototype.getDetachedServiceId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.ServiceDetachTalkResponse} returns this
 */
proto.ServiceDetachTalkResponse.prototype.setDetachedServiceId = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ServiceTalkReloadResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.ServiceTalkReloadResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ServiceTalkReloadResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceTalkReloadResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    talk: (f = msg.getTalk()) && proto.ServiceTalkInfoAndMessages.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ServiceTalkReloadResponse}
 */
proto.ServiceTalkReloadResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ServiceTalkReloadResponse;
  return proto.ServiceTalkReloadResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ServiceTalkReloadResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ServiceTalkReloadResponse}
 */
proto.ServiceTalkReloadResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.ServiceTalkInfoAndMessages;
      reader.readMessage(value,proto.ServiceTalkInfoAndMessages.deserializeBinaryFromReader);
      msg.setTalk(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ServiceTalkReloadResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ServiceTalkReloadResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ServiceTalkReloadResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceTalkReloadResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTalk();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.ServiceTalkInfoAndMessages.serializeBinaryToWriter
    );
  }
};


/**
 * optional ServiceTalkInfoAndMessages talk = 1;
 * @return {?proto.ServiceTalkInfoAndMessages}
 */
proto.ServiceTalkReloadResponse.prototype.getTalk = function() {
  return /** @type{?proto.ServiceTalkInfoAndMessages} */ (
    jspb.Message.getWrapperField(this, proto.ServiceTalkInfoAndMessages, 1));
};


/**
 * @param {?proto.ServiceTalkInfoAndMessages|undefined} value
 * @return {!proto.ServiceTalkReloadResponse} returns this
*/
proto.ServiceTalkReloadResponse.prototype.setTalk = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ServiceTalkReloadResponse} returns this
 */
proto.ServiceTalkReloadResponse.prototype.clearTalk = function() {
  return this.setTalk(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ServiceTalkReloadResponse.prototype.hasTalk = function() {
  return jspb.Message.getField(this, 1) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ServiceTalkMessageResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.ServiceTalkMessageResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ServiceTalkMessageResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceTalkMessageResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    talkId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    message: (f = msg.getMessage()) && proto.TalkMessage.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ServiceTalkMessageResponse}
 */
proto.ServiceTalkMessageResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ServiceTalkMessageResponse;
  return proto.ServiceTalkMessageResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ServiceTalkMessageResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ServiceTalkMessageResponse}
 */
proto.ServiceTalkMessageResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setTalkId(value);
      break;
    case 2:
      var value = new proto.TalkMessage;
      reader.readMessage(value,proto.TalkMessage.deserializeBinaryFromReader);
      msg.setMessage(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ServiceTalkMessageResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ServiceTalkMessageResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ServiceTalkMessageResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceTalkMessageResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTalkId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getMessage();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.TalkMessage.serializeBinaryToWriter
    );
  }
};


/**
 * optional string talk_id = 1;
 * @return {string}
 */
proto.ServiceTalkMessageResponse.prototype.getTalkId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.ServiceTalkMessageResponse} returns this
 */
proto.ServiceTalkMessageResponse.prototype.setTalkId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional TalkMessage message = 2;
 * @return {?proto.TalkMessage}
 */
proto.ServiceTalkMessageResponse.prototype.getMessage = function() {
  return /** @type{?proto.TalkMessage} */ (
    jspb.Message.getWrapperField(this, proto.TalkMessage, 2));
};


/**
 * @param {?proto.TalkMessage|undefined} value
 * @return {!proto.ServiceTalkMessageResponse} returns this
*/
proto.ServiceTalkMessageResponse.prototype.setMessage = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ServiceTalkMessageResponse} returns this
 */
proto.ServiceTalkMessageResponse.prototype.clearMessage = function() {
  return this.setMessage(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ServiceTalkMessageResponse.prototype.hasMessage = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ServiceTalkNotifyResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.ServiceTalkNotifyResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ServiceTalkNotifyResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceTalkNotifyResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    msg: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ServiceTalkNotifyResponse}
 */
proto.ServiceTalkNotifyResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ServiceTalkNotifyResponse;
  return proto.ServiceTalkNotifyResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ServiceTalkNotifyResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ServiceTalkNotifyResponse}
 */
proto.ServiceTalkNotifyResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMsg(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ServiceTalkNotifyResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ServiceTalkNotifyResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ServiceTalkNotifyResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceTalkNotifyResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMsg();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string msg = 1;
 * @return {string}
 */
proto.ServiceTalkNotifyResponse.prototype.getMsg = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.ServiceTalkNotifyResponse} returns this
 */
proto.ServiceTalkNotifyResponse.prototype.setMsg = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ServiceMessageConfirmed.prototype.toObject = function(opt_includeInstance) {
  return proto.ServiceMessageConfirmed.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ServiceMessageConfirmed} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceMessageConfirmed.toObject = function(includeInstance, msg) {
  var f, obj = {
    seqId: jspb.Message.getFieldWithDefault(msg, 1, 0),
    at: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ServiceMessageConfirmed}
 */
proto.ServiceMessageConfirmed.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ServiceMessageConfirmed;
  return proto.ServiceMessageConfirmed.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ServiceMessageConfirmed} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ServiceMessageConfirmed}
 */
proto.ServiceMessageConfirmed.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setSeqId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setAt(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ServiceMessageConfirmed.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ServiceMessageConfirmed.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ServiceMessageConfirmed} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceMessageConfirmed.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSeqId();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getAt();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
};


/**
 * optional uint64 seq_id = 1;
 * @return {number}
 */
proto.ServiceMessageConfirmed.prototype.getSeqId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.ServiceMessageConfirmed} returns this
 */
proto.ServiceMessageConfirmed.prototype.setSeqId = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint64 at = 2;
 * @return {number}
 */
proto.ServiceMessageConfirmed.prototype.getAt = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.ServiceMessageConfirmed} returns this
 */
proto.ServiceMessageConfirmed.prototype.setAt = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ServiceTalkClose.prototype.toObject = function(opt_includeInstance) {
  return proto.ServiceTalkClose.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ServiceTalkClose} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceTalkClose.toObject = function(includeInstance, msg) {
  var f, obj = {
    talkId: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ServiceTalkClose}
 */
proto.ServiceTalkClose.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ServiceTalkClose;
  return proto.ServiceTalkClose.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ServiceTalkClose} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ServiceTalkClose}
 */
proto.ServiceTalkClose.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setTalkId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ServiceTalkClose.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ServiceTalkClose.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ServiceTalkClose} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceTalkClose.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTalkId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string talk_id = 1;
 * @return {string}
 */
proto.ServiceTalkClose.prototype.getTalkId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.ServiceTalkClose} returns this
 */
proto.ServiceTalkClose.prototype.setTalkId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.ServiceResponse.oneofGroups_ = [[1,2,3,4,5,6,7,8,9,10]];

/**
 * @enum {number}
 */
proto.ServiceResponse.ResponseCase = {
  RESPONSE_NOT_SET: 0,
  KICK_OUT: 1,
  PENDING_TALKS: 2,
  TALKS: 3,
  ATTACH: 4,
  DETACH: 5,
  RELOAD: 6,
  MESSAGE: 7,
  NOTIFY: 8,
  MESSAGE_CONFIRMED: 9,
  CLOSE: 10
};

/**
 * @return {proto.ServiceResponse.ResponseCase}
 */
proto.ServiceResponse.prototype.getResponseCase = function() {
  return /** @type {proto.ServiceResponse.ResponseCase} */(jspb.Message.computeOneofCase(this, proto.ServiceResponse.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ServiceResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.ServiceResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ServiceResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    kickOut: (f = msg.getKickOut()) && proto.TalkKickOutMessage.toObject(includeInstance, f),
    pendingTalks: (f = msg.getPendingTalks()) && proto.ServicePendingTalksResponse.toObject(includeInstance, f),
    talks: (f = msg.getTalks()) && proto.ServiceAttachedTalksResponse.toObject(includeInstance, f),
    attach: (f = msg.getAttach()) && proto.ServiceAttachTalkResponse.toObject(includeInstance, f),
    detach: (f = msg.getDetach()) && proto.ServiceDetachTalkResponse.toObject(includeInstance, f),
    reload: (f = msg.getReload()) && proto.ServiceTalkReloadResponse.toObject(includeInstance, f),
    message: (f = msg.getMessage()) && proto.ServiceTalkMessageResponse.toObject(includeInstance, f),
    notify: (f = msg.getNotify()) && proto.ServiceTalkNotifyResponse.toObject(includeInstance, f),
    messageConfirmed: (f = msg.getMessageConfirmed()) && proto.ServiceMessageConfirmed.toObject(includeInstance, f),
    close: (f = msg.getClose()) && proto.ServiceTalkClose.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ServiceResponse}
 */
proto.ServiceResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ServiceResponse;
  return proto.ServiceResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ServiceResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ServiceResponse}
 */
proto.ServiceResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.TalkKickOutMessage;
      reader.readMessage(value,proto.TalkKickOutMessage.deserializeBinaryFromReader);
      msg.setKickOut(value);
      break;
    case 2:
      var value = new proto.ServicePendingTalksResponse;
      reader.readMessage(value,proto.ServicePendingTalksResponse.deserializeBinaryFromReader);
      msg.setPendingTalks(value);
      break;
    case 3:
      var value = new proto.ServiceAttachedTalksResponse;
      reader.readMessage(value,proto.ServiceAttachedTalksResponse.deserializeBinaryFromReader);
      msg.setTalks(value);
      break;
    case 4:
      var value = new proto.ServiceAttachTalkResponse;
      reader.readMessage(value,proto.ServiceAttachTalkResponse.deserializeBinaryFromReader);
      msg.setAttach(value);
      break;
    case 5:
      var value = new proto.ServiceDetachTalkResponse;
      reader.readMessage(value,proto.ServiceDetachTalkResponse.deserializeBinaryFromReader);
      msg.setDetach(value);
      break;
    case 6:
      var value = new proto.ServiceTalkReloadResponse;
      reader.readMessage(value,proto.ServiceTalkReloadResponse.deserializeBinaryFromReader);
      msg.setReload(value);
      break;
    case 7:
      var value = new proto.ServiceTalkMessageResponse;
      reader.readMessage(value,proto.ServiceTalkMessageResponse.deserializeBinaryFromReader);
      msg.setMessage(value);
      break;
    case 8:
      var value = new proto.ServiceTalkNotifyResponse;
      reader.readMessage(value,proto.ServiceTalkNotifyResponse.deserializeBinaryFromReader);
      msg.setNotify(value);
      break;
    case 9:
      var value = new proto.ServiceMessageConfirmed;
      reader.readMessage(value,proto.ServiceMessageConfirmed.deserializeBinaryFromReader);
      msg.setMessageConfirmed(value);
      break;
    case 10:
      var value = new proto.ServiceTalkClose;
      reader.readMessage(value,proto.ServiceTalkClose.deserializeBinaryFromReader);
      msg.setClose(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ServiceResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ServiceResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ServiceResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ServiceResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getKickOut();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.TalkKickOutMessage.serializeBinaryToWriter
    );
  }
  f = message.getPendingTalks();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.ServicePendingTalksResponse.serializeBinaryToWriter
    );
  }
  f = message.getTalks();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.ServiceAttachedTalksResponse.serializeBinaryToWriter
    );
  }
  f = message.getAttach();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.ServiceAttachTalkResponse.serializeBinaryToWriter
    );
  }
  f = message.getDetach();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.ServiceDetachTalkResponse.serializeBinaryToWriter
    );
  }
  f = message.getReload();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.ServiceTalkReloadResponse.serializeBinaryToWriter
    );
  }
  f = message.getMessage();
  if (f != null) {
    writer.writeMessage(
      7,
      f,
      proto.ServiceTalkMessageResponse.serializeBinaryToWriter
    );
  }
  f = message.getNotify();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      proto.ServiceTalkNotifyResponse.serializeBinaryToWriter
    );
  }
  f = message.getMessageConfirmed();
  if (f != null) {
    writer.writeMessage(
      9,
      f,
      proto.ServiceMessageConfirmed.serializeBinaryToWriter
    );
  }
  f = message.getClose();
  if (f != null) {
    writer.writeMessage(
      10,
      f,
      proto.ServiceTalkClose.serializeBinaryToWriter
    );
  }
};


/**
 * optional TalkKickOutMessage kick_out = 1;
 * @return {?proto.TalkKickOutMessage}
 */
proto.ServiceResponse.prototype.getKickOut = function() {
  return /** @type{?proto.TalkKickOutMessage} */ (
    jspb.Message.getWrapperField(this, proto.TalkKickOutMessage, 1));
};


/**
 * @param {?proto.TalkKickOutMessage|undefined} value
 * @return {!proto.ServiceResponse} returns this
*/
proto.ServiceResponse.prototype.setKickOut = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.ServiceResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ServiceResponse} returns this
 */
proto.ServiceResponse.prototype.clearKickOut = function() {
  return this.setKickOut(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ServiceResponse.prototype.hasKickOut = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ServicePendingTalksResponse pending_talks = 2;
 * @return {?proto.ServicePendingTalksResponse}
 */
proto.ServiceResponse.prototype.getPendingTalks = function() {
  return /** @type{?proto.ServicePendingTalksResponse} */ (
    jspb.Message.getWrapperField(this, proto.ServicePendingTalksResponse, 2));
};


/**
 * @param {?proto.ServicePendingTalksResponse|undefined} value
 * @return {!proto.ServiceResponse} returns this
*/
proto.ServiceResponse.prototype.setPendingTalks = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.ServiceResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ServiceResponse} returns this
 */
proto.ServiceResponse.prototype.clearPendingTalks = function() {
  return this.setPendingTalks(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ServiceResponse.prototype.hasPendingTalks = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional ServiceAttachedTalksResponse talks = 3;
 * @return {?proto.ServiceAttachedTalksResponse}
 */
proto.ServiceResponse.prototype.getTalks = function() {
  return /** @type{?proto.ServiceAttachedTalksResponse} */ (
    jspb.Message.getWrapperField(this, proto.ServiceAttachedTalksResponse, 3));
};


/**
 * @param {?proto.ServiceAttachedTalksResponse|undefined} value
 * @return {!proto.ServiceResponse} returns this
*/
proto.ServiceResponse.prototype.setTalks = function(value) {
  return jspb.Message.setOneofWrapperField(this, 3, proto.ServiceResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ServiceResponse} returns this
 */
proto.ServiceResponse.prototype.clearTalks = function() {
  return this.setTalks(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ServiceResponse.prototype.hasTalks = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional ServiceAttachTalkResponse attach = 4;
 * @return {?proto.ServiceAttachTalkResponse}
 */
proto.ServiceResponse.prototype.getAttach = function() {
  return /** @type{?proto.ServiceAttachTalkResponse} */ (
    jspb.Message.getWrapperField(this, proto.ServiceAttachTalkResponse, 4));
};


/**
 * @param {?proto.ServiceAttachTalkResponse|undefined} value
 * @return {!proto.ServiceResponse} returns this
*/
proto.ServiceResponse.prototype.setAttach = function(value) {
  return jspb.Message.setOneofWrapperField(this, 4, proto.ServiceResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ServiceResponse} returns this
 */
proto.ServiceResponse.prototype.clearAttach = function() {
  return this.setAttach(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ServiceResponse.prototype.hasAttach = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional ServiceDetachTalkResponse detach = 5;
 * @return {?proto.ServiceDetachTalkResponse}
 */
proto.ServiceResponse.prototype.getDetach = function() {
  return /** @type{?proto.ServiceDetachTalkResponse} */ (
    jspb.Message.getWrapperField(this, proto.ServiceDetachTalkResponse, 5));
};


/**
 * @param {?proto.ServiceDetachTalkResponse|undefined} value
 * @return {!proto.ServiceResponse} returns this
*/
proto.ServiceResponse.prototype.setDetach = function(value) {
  return jspb.Message.setOneofWrapperField(this, 5, proto.ServiceResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ServiceResponse} returns this
 */
proto.ServiceResponse.prototype.clearDetach = function() {
  return this.setDetach(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ServiceResponse.prototype.hasDetach = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional ServiceTalkReloadResponse reload = 6;
 * @return {?proto.ServiceTalkReloadResponse}
 */
proto.ServiceResponse.prototype.getReload = function() {
  return /** @type{?proto.ServiceTalkReloadResponse} */ (
    jspb.Message.getWrapperField(this, proto.ServiceTalkReloadResponse, 6));
};


/**
 * @param {?proto.ServiceTalkReloadResponse|undefined} value
 * @return {!proto.ServiceResponse} returns this
*/
proto.ServiceResponse.prototype.setReload = function(value) {
  return jspb.Message.setOneofWrapperField(this, 6, proto.ServiceResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ServiceResponse} returns this
 */
proto.ServiceResponse.prototype.clearReload = function() {
  return this.setReload(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ServiceResponse.prototype.hasReload = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional ServiceTalkMessageResponse message = 7;
 * @return {?proto.ServiceTalkMessageResponse}
 */
proto.ServiceResponse.prototype.getMessage = function() {
  return /** @type{?proto.ServiceTalkMessageResponse} */ (
    jspb.Message.getWrapperField(this, proto.ServiceTalkMessageResponse, 7));
};


/**
 * @param {?proto.ServiceTalkMessageResponse|undefined} value
 * @return {!proto.ServiceResponse} returns this
*/
proto.ServiceResponse.prototype.setMessage = function(value) {
  return jspb.Message.setOneofWrapperField(this, 7, proto.ServiceResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ServiceResponse} returns this
 */
proto.ServiceResponse.prototype.clearMessage = function() {
  return this.setMessage(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ServiceResponse.prototype.hasMessage = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional ServiceTalkNotifyResponse notify = 8;
 * @return {?proto.ServiceTalkNotifyResponse}
 */
proto.ServiceResponse.prototype.getNotify = function() {
  return /** @type{?proto.ServiceTalkNotifyResponse} */ (
    jspb.Message.getWrapperField(this, proto.ServiceTalkNotifyResponse, 8));
};


/**
 * @param {?proto.ServiceTalkNotifyResponse|undefined} value
 * @return {!proto.ServiceResponse} returns this
*/
proto.ServiceResponse.prototype.setNotify = function(value) {
  return jspb.Message.setOneofWrapperField(this, 8, proto.ServiceResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ServiceResponse} returns this
 */
proto.ServiceResponse.prototype.clearNotify = function() {
  return this.setNotify(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ServiceResponse.prototype.hasNotify = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional ServiceMessageConfirmed message_confirmed = 9;
 * @return {?proto.ServiceMessageConfirmed}
 */
proto.ServiceResponse.prototype.getMessageConfirmed = function() {
  return /** @type{?proto.ServiceMessageConfirmed} */ (
    jspb.Message.getWrapperField(this, proto.ServiceMessageConfirmed, 9));
};


/**
 * @param {?proto.ServiceMessageConfirmed|undefined} value
 * @return {!proto.ServiceResponse} returns this
*/
proto.ServiceResponse.prototype.setMessageConfirmed = function(value) {
  return jspb.Message.setOneofWrapperField(this, 9, proto.ServiceResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ServiceResponse} returns this
 */
proto.ServiceResponse.prototype.clearMessageConfirmed = function() {
  return this.setMessageConfirmed(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ServiceResponse.prototype.hasMessageConfirmed = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional ServiceTalkClose close = 10;
 * @return {?proto.ServiceTalkClose}
 */
proto.ServiceResponse.prototype.getClose = function() {
  return /** @type{?proto.ServiceTalkClose} */ (
    jspb.Message.getWrapperField(this, proto.ServiceTalkClose, 10));
};


/**
 * @param {?proto.ServiceTalkClose|undefined} value
 * @return {!proto.ServiceResponse} returns this
*/
proto.ServiceResponse.prototype.setClose = function(value) {
  return jspb.Message.setOneofWrapperField(this, 10, proto.ServiceResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ServiceResponse} returns this
 */
proto.ServiceResponse.prototype.clearClose = function() {
  return this.setClose(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ServiceResponse.prototype.hasClose = function() {
  return jspb.Message.getField(this, 10) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.CheckTokenRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.CheckTokenRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.CheckTokenRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CheckTokenRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    actId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    bizId: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.CheckTokenRequest}
 */
proto.CheckTokenRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.CheckTokenRequest;
  return proto.CheckTokenRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.CheckTokenRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.CheckTokenRequest}
 */
proto.CheckTokenRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setActId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setBizId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.CheckTokenRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.CheckTokenRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.CheckTokenRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CheckTokenRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getActId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getBizId();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional string act_id = 1;
 * @return {string}
 */
proto.CheckTokenRequest.prototype.getActId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.CheckTokenRequest} returns this
 */
proto.CheckTokenRequest.prototype.setActId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string biz_id = 2;
 * @return {string}
 */
proto.CheckTokenRequest.prototype.getBizId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.CheckTokenRequest} returns this
 */
proto.CheckTokenRequest.prototype.setBizId = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.CheckTokenResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.CheckTokenResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.CheckTokenResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CheckTokenResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    valid: jspb.Message.getBooleanFieldWithDefault(msg, 1, false),
    userName: jspb.Message.getFieldWithDefault(msg, 2, ""),
    newToken: jspb.Message.getFieldWithDefault(msg, 3, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.CheckTokenResponse}
 */
proto.CheckTokenResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.CheckTokenResponse;
  return proto.CheckTokenResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.CheckTokenResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.CheckTokenResponse}
 */
proto.CheckTokenResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setValid(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setUserName(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setNewToken(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.CheckTokenResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.CheckTokenResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.CheckTokenResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CheckTokenResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValid();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = message.getUserName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getNewToken();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * optional bool valid = 1;
 * @return {boolean}
 */
proto.CheckTokenResponse.prototype.getValid = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 1, false));
};


/**
 * @param {boolean} value
 * @return {!proto.CheckTokenResponse} returns this
 */
proto.CheckTokenResponse.prototype.setValid = function(value) {
  return jspb.Message.setProto3BooleanField(this, 1, value);
};


/**
 * optional string user_name = 2;
 * @return {string}
 */
proto.CheckTokenResponse.prototype.getUserName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.CheckTokenResponse} returns this
 */
proto.CheckTokenResponse.prototype.setUserName = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string new_token = 3;
 * @return {string}
 */
proto.CheckTokenResponse.prototype.getNewToken = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.CheckTokenResponse} returns this
 */
proto.CheckTokenResponse.prototype.setNewToken = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.CreateTokenRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.CreateTokenRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.CreateTokenRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CreateTokenRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    userName: jspb.Message.getFieldWithDefault(msg, 1, ""),
    actId: jspb.Message.getFieldWithDefault(msg, 2, ""),
    bizId: jspb.Message.getFieldWithDefault(msg, 3, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.CreateTokenRequest}
 */
proto.CreateTokenRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.CreateTokenRequest;
  return proto.CreateTokenRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.CreateTokenRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.CreateTokenRequest}
 */
proto.CreateTokenRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setUserName(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setActId(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setBizId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.CreateTokenRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.CreateTokenRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.CreateTokenRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CreateTokenRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getUserName();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getActId();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getBizId();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * optional string user_name = 1;
 * @return {string}
 */
proto.CreateTokenRequest.prototype.getUserName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.CreateTokenRequest} returns this
 */
proto.CreateTokenRequest.prototype.setUserName = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string act_id = 2;
 * @return {string}
 */
proto.CreateTokenRequest.prototype.getActId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.CreateTokenRequest} returns this
 */
proto.CreateTokenRequest.prototype.setActId = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string biz_id = 3;
 * @return {string}
 */
proto.CreateTokenRequest.prototype.getBizId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.CreateTokenRequest} returns this
 */
proto.CreateTokenRequest.prototype.setBizId = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.CreateTokenResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.CreateTokenResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.CreateTokenResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CreateTokenResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    token: jspb.Message.getFieldWithDefault(msg, 1, ""),
    userName: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.CreateTokenResponse}
 */
proto.CreateTokenResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.CreateTokenResponse;
  return proto.CreateTokenResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.CreateTokenResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.CreateTokenResponse}
 */
proto.CreateTokenResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setToken(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setUserName(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.CreateTokenResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.CreateTokenResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.CreateTokenResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CreateTokenResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getToken();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getUserName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional string token = 1;
 * @return {string}
 */
proto.CreateTokenResponse.prototype.getToken = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.CreateTokenResponse} returns this
 */
proto.CreateTokenResponse.prototype.setToken = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string user_name = 2;
 * @return {string}
 */
proto.CreateTokenResponse.prototype.getUserName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.CreateTokenResponse} returns this
 */
proto.CreateTokenResponse.prototype.setUserName = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.RegisterRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.RegisterRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.RegisterRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.RegisterRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    userName: jspb.Message.getFieldWithDefault(msg, 1, ""),
    password: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.RegisterRequest}
 */
proto.RegisterRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.RegisterRequest;
  return proto.RegisterRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.RegisterRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.RegisterRequest}
 */
proto.RegisterRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setUserName(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setPassword(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.RegisterRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.RegisterRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.RegisterRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.RegisterRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getUserName();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getPassword();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional string user_name = 1;
 * @return {string}
 */
proto.RegisterRequest.prototype.getUserName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.RegisterRequest} returns this
 */
proto.RegisterRequest.prototype.setUserName = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string password = 2;
 * @return {string}
 */
proto.RegisterRequest.prototype.getPassword = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.RegisterRequest} returns this
 */
proto.RegisterRequest.prototype.setPassword = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.RegisterResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.RegisterResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.RegisterResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.RegisterResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    token: jspb.Message.getFieldWithDefault(msg, 1, ""),
    userName: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.RegisterResponse}
 */
proto.RegisterResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.RegisterResponse;
  return proto.RegisterResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.RegisterResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.RegisterResponse}
 */
proto.RegisterResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setToken(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setUserName(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.RegisterResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.RegisterResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.RegisterResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.RegisterResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getToken();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getUserName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional string token = 1;
 * @return {string}
 */
proto.RegisterResponse.prototype.getToken = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.RegisterResponse} returns this
 */
proto.RegisterResponse.prototype.setToken = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string user_name = 2;
 * @return {string}
 */
proto.RegisterResponse.prototype.getUserName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.RegisterResponse} returns this
 */
proto.RegisterResponse.prototype.setUserName = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.LoginRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.LoginRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.LoginRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.LoginRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    userName: jspb.Message.getFieldWithDefault(msg, 1, ""),
    password: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.LoginRequest}
 */
proto.LoginRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.LoginRequest;
  return proto.LoginRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.LoginRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.LoginRequest}
 */
proto.LoginRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setUserName(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setPassword(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.LoginRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.LoginRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.LoginRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.LoginRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getUserName();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getPassword();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional string user_name = 1;
 * @return {string}
 */
proto.LoginRequest.prototype.getUserName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.LoginRequest} returns this
 */
proto.LoginRequest.prototype.setUserName = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string password = 2;
 * @return {string}
 */
proto.LoginRequest.prototype.getPassword = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.LoginRequest} returns this
 */
proto.LoginRequest.prototype.setPassword = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.LoginResponse.repeatedFields_ = [3,4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.LoginResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.LoginResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.LoginResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.LoginResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    token: jspb.Message.getFieldWithDefault(msg, 1, ""),
    userName: jspb.Message.getFieldWithDefault(msg, 2, ""),
    actIdsList: (f = jspb.Message.getRepeatedField(msg, 3)) == null ? undefined : f,
    bizIdsList: (f = jspb.Message.getRepeatedField(msg, 4)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.LoginResponse}
 */
proto.LoginResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.LoginResponse;
  return proto.LoginResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.LoginResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.LoginResponse}
 */
proto.LoginResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setToken(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setUserName(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.addActIds(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.addBizIds(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.LoginResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.LoginResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.LoginResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.LoginResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getToken();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getUserName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getActIdsList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      3,
      f
    );
  }
  f = message.getBizIdsList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      4,
      f
    );
  }
};


/**
 * optional string token = 1;
 * @return {string}
 */
proto.LoginResponse.prototype.getToken = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.LoginResponse} returns this
 */
proto.LoginResponse.prototype.setToken = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string user_name = 2;
 * @return {string}
 */
proto.LoginResponse.prototype.getUserName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.LoginResponse} returns this
 */
proto.LoginResponse.prototype.setUserName = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * repeated string act_ids = 3;
 * @return {!Array<string>}
 */
proto.LoginResponse.prototype.getActIdsList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 3));
};


/**
 * @param {!Array<string>} value
 * @return {!proto.LoginResponse} returns this
 */
proto.LoginResponse.prototype.setActIdsList = function(value) {
  return jspb.Message.setField(this, 3, value || []);
};


/**
 * @param {string} value
 * @param {number=} opt_index
 * @return {!proto.LoginResponse} returns this
 */
proto.LoginResponse.prototype.addActIds = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 3, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.LoginResponse} returns this
 */
proto.LoginResponse.prototype.clearActIdsList = function() {
  return this.setActIdsList([]);
};


/**
 * repeated string biz_ids = 4;
 * @return {!Array<string>}
 */
proto.LoginResponse.prototype.getBizIdsList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 4));
};


/**
 * @param {!Array<string>} value
 * @return {!proto.LoginResponse} returns this
 */
proto.LoginResponse.prototype.setBizIdsList = function(value) {
  return jspb.Message.setField(this, 4, value || []);
};


/**
 * @param {string} value
 * @param {number=} opt_index
 * @return {!proto.LoginResponse} returns this
 */
proto.LoginResponse.prototype.addBizIds = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 4, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.LoginResponse} returns this
 */
proto.LoginResponse.prototype.clearBizIdsList = function() {
  return this.setBizIdsList([]);
};


/**
 * @enum {number}
 */
proto.TalkStatus = {
  TALK_STATUS_UNSPECIFIED: 0,
  TALK_STATUS_OPENED: 1,
  TALK_STATUS_CLOSED: 2
};

goog.object.extend(exports, proto);
