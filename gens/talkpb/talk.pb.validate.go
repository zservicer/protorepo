// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: proto/talk.proto

package talkpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Empty with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Empty) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Empty with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EmptyMultiError, or nil if none found.
func (m *Empty) ValidateAll() error {
	return m.validate(true)
}

func (m *Empty) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return EmptyMultiError(errors)
	}

	return nil
}

// EmptyMultiError is an error wrapping multiple validation errors returned by
// Empty.ValidateAll() if the designated constraints aren't met.
type EmptyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmptyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmptyMultiError) AllErrors() []error { return m }

// EmptyValidationError is the validation error returned by Empty.Validate if
// the designated constraints aren't met.
type EmptyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmptyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmptyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmptyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmptyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmptyValidationError) ErrorName() string { return "EmptyValidationError" }

// Error satisfies the builtin error interface
func (e EmptyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmpty.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmptyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmptyValidationError{}

// Validate checks the field values on TalkKickOutMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TalkKickOutMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TalkKickOutMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TalkKickOutMessageMultiError, or nil if none found.
func (m *TalkKickOutMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *TalkKickOutMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if len(errors) > 0 {
		return TalkKickOutMessageMultiError(errors)
	}

	return nil
}

// TalkKickOutMessageMultiError is an error wrapping multiple validation errors
// returned by TalkKickOutMessage.ValidateAll() if the designated constraints
// aren't met.
type TalkKickOutMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TalkKickOutMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TalkKickOutMessageMultiError) AllErrors() []error { return m }

// TalkKickOutMessageValidationError is the validation error returned by
// TalkKickOutMessage.Validate if the designated constraints aren't met.
type TalkKickOutMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TalkKickOutMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TalkKickOutMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TalkKickOutMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TalkKickOutMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TalkKickOutMessageValidationError) ErrorName() string {
	return "TalkKickOutMessageValidationError"
}

// Error satisfies the builtin error interface
func (e TalkKickOutMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTalkKickOutMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TalkKickOutMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TalkKickOutMessageValidationError{}

// Validate checks the field values on QueryTalksRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *QueryTalksRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryTalksRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryTalksRequestMultiError, or nil if none found.
func (m *QueryTalksRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryTalksRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return QueryTalksRequestMultiError(errors)
	}

	return nil
}

// QueryTalksRequestMultiError is an error wrapping multiple validation errors
// returned by QueryTalksRequest.ValidateAll() if the designated constraints
// aren't met.
type QueryTalksRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryTalksRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryTalksRequestMultiError) AllErrors() []error { return m }

// QueryTalksRequestValidationError is the validation error returned by
// QueryTalksRequest.Validate if the designated constraints aren't met.
type QueryTalksRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryTalksRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryTalksRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryTalksRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryTalksRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryTalksRequestValidationError) ErrorName() string {
	return "QueryTalksRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryTalksRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryTalksRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryTalksRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryTalksRequestValidationError{}

// Validate checks the field values on TalkInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TalkInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TalkInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TalkInfoMultiError, or nil
// if none found.
func (m *TalkInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *TalkInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TalkId

	// no validation rules for Status

	// no validation rules for Title

	// no validation rules for StartedAt

	// no validation rules for FinishedAt

	// no validation rules for CustomerName

	if len(errors) > 0 {
		return TalkInfoMultiError(errors)
	}

	return nil
}

// TalkInfoMultiError is an error wrapping multiple validation errors returned
// by TalkInfo.ValidateAll() if the designated constraints aren't met.
type TalkInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TalkInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TalkInfoMultiError) AllErrors() []error { return m }

// TalkInfoValidationError is the validation error returned by
// TalkInfo.Validate if the designated constraints aren't met.
type TalkInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TalkInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TalkInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TalkInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TalkInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TalkInfoValidationError) ErrorName() string { return "TalkInfoValidationError" }

// Error satisfies the builtin error interface
func (e TalkInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTalkInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TalkInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TalkInfoValidationError{}

// Validate checks the field values on QueryTalksResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryTalksResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryTalksResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryTalksResponseMultiError, or nil if none found.
func (m *QueryTalksResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryTalksResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTalks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryTalksResponseValidationError{
						field:  fmt.Sprintf("Talks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryTalksResponseValidationError{
						field:  fmt.Sprintf("Talks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryTalksResponseValidationError{
					field:  fmt.Sprintf("Talks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return QueryTalksResponseMultiError(errors)
	}

	return nil
}

// QueryTalksResponseMultiError is an error wrapping multiple validation errors
// returned by QueryTalksResponse.ValidateAll() if the designated constraints
// aren't met.
type QueryTalksResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryTalksResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryTalksResponseMultiError) AllErrors() []error { return m }

// QueryTalksResponseValidationError is the validation error returned by
// QueryTalksResponse.Validate if the designated constraints aren't met.
type QueryTalksResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryTalksResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryTalksResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryTalksResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryTalksResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryTalksResponseValidationError) ErrorName() string {
	return "QueryTalksResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryTalksResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryTalksResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryTalksResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryTalksResponseValidationError{}

// Validate checks the field values on TalkCreateRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TalkCreateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TalkCreateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TalkCreateRequestMultiError, or nil if none found.
func (m *TalkCreateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TalkCreateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	if len(errors) > 0 {
		return TalkCreateRequestMultiError(errors)
	}

	return nil
}

// TalkCreateRequestMultiError is an error wrapping multiple validation errors
// returned by TalkCreateRequest.ValidateAll() if the designated constraints
// aren't met.
type TalkCreateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TalkCreateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TalkCreateRequestMultiError) AllErrors() []error { return m }

// TalkCreateRequestValidationError is the validation error returned by
// TalkCreateRequest.Validate if the designated constraints aren't met.
type TalkCreateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TalkCreateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TalkCreateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TalkCreateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TalkCreateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TalkCreateRequestValidationError) ErrorName() string {
	return "TalkCreateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TalkCreateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTalkCreateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TalkCreateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TalkCreateRequestValidationError{}

// Validate checks the field values on TalkOpenRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TalkOpenRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TalkOpenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TalkOpenRequestMultiError, or nil if none found.
func (m *TalkOpenRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TalkOpenRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TalkId

	if len(errors) > 0 {
		return TalkOpenRequestMultiError(errors)
	}

	return nil
}

// TalkOpenRequestMultiError is an error wrapping multiple validation errors
// returned by TalkOpenRequest.ValidateAll() if the designated constraints
// aren't met.
type TalkOpenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TalkOpenRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TalkOpenRequestMultiError) AllErrors() []error { return m }

// TalkOpenRequestValidationError is the validation error returned by
// TalkOpenRequest.Validate if the designated constraints aren't met.
type TalkOpenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TalkOpenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TalkOpenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TalkOpenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TalkOpenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TalkOpenRequestValidationError) ErrorName() string { return "TalkOpenRequestValidationError" }

// Error satisfies the builtin error interface
func (e TalkOpenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTalkOpenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TalkOpenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TalkOpenRequestValidationError{}

// Validate checks the field values on TalkMessageW with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TalkMessageW) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TalkMessageW with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TalkMessageWMultiError, or
// nil if none found.
func (m *TalkMessageW) ValidateAll() error {
	return m.validate(true)
}

func (m *TalkMessageW) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SeqId

	switch m.Message.(type) {

	case *TalkMessageW_Text:
		// no validation rules for Text

	case *TalkMessageW_Image:
		// no validation rules for Image

	}

	if len(errors) > 0 {
		return TalkMessageWMultiError(errors)
	}

	return nil
}

// TalkMessageWMultiError is an error wrapping multiple validation errors
// returned by TalkMessageW.ValidateAll() if the designated constraints aren't met.
type TalkMessageWMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TalkMessageWMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TalkMessageWMultiError) AllErrors() []error { return m }

// TalkMessageWValidationError is the validation error returned by
// TalkMessageW.Validate if the designated constraints aren't met.
type TalkMessageWValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TalkMessageWValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TalkMessageWValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TalkMessageWValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TalkMessageWValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TalkMessageWValidationError) ErrorName() string { return "TalkMessageWValidationError" }

// Error satisfies the builtin error interface
func (e TalkMessageWValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTalkMessageW.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TalkMessageWValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TalkMessageWValidationError{}

// Validate checks the field values on TalkMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TalkMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TalkMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TalkMessageMultiError, or
// nil if none found.
func (m *TalkMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *TalkMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for At

	// no validation rules for CustomerMessage

	// no validation rules for User

	switch m.Message.(type) {

	case *TalkMessage_Text:
		// no validation rules for Text

	case *TalkMessage_Image:
		// no validation rules for Image

	}

	if len(errors) > 0 {
		return TalkMessageMultiError(errors)
	}

	return nil
}

// TalkMessageMultiError is an error wrapping multiple validation errors
// returned by TalkMessage.ValidateAll() if the designated constraints aren't met.
type TalkMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TalkMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TalkMessageMultiError) AllErrors() []error { return m }

// TalkMessageValidationError is the validation error returned by
// TalkMessage.Validate if the designated constraints aren't met.
type TalkMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TalkMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TalkMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TalkMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TalkMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TalkMessageValidationError) ErrorName() string { return "TalkMessageValidationError" }

// Error satisfies the builtin error interface
func (e TalkMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTalkMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TalkMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TalkMessageValidationError{}

// Validate checks the field values on TalkClose with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TalkClose) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TalkClose with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TalkCloseMultiError, or nil
// if none found.
func (m *TalkClose) ValidateAll() error {
	return m.validate(true)
}

func (m *TalkClose) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TalkCloseMultiError(errors)
	}

	return nil
}

// TalkCloseMultiError is an error wrapping multiple validation errors returned
// by TalkClose.ValidateAll() if the designated constraints aren't met.
type TalkCloseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TalkCloseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TalkCloseMultiError) AllErrors() []error { return m }

// TalkCloseValidationError is the validation error returned by
// TalkClose.Validate if the designated constraints aren't met.
type TalkCloseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TalkCloseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TalkCloseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TalkCloseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TalkCloseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TalkCloseValidationError) ErrorName() string { return "TalkCloseValidationError" }

// Error satisfies the builtin error interface
func (e TalkCloseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTalkClose.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TalkCloseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TalkCloseValidationError{}

// Validate checks the field values on TalkRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TalkRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TalkRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TalkRequestMultiError, or
// nil if none found.
func (m *TalkRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TalkRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Talk.(type) {

	case *TalkRequest_Create:

		if all {
			switch v := interface{}(m.GetCreate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TalkRequestValidationError{
						field:  "Create",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TalkRequestValidationError{
						field:  "Create",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TalkRequestValidationError{
					field:  "Create",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TalkRequest_Open:

		if all {
			switch v := interface{}(m.GetOpen()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TalkRequestValidationError{
						field:  "Open",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TalkRequestValidationError{
						field:  "Open",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOpen()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TalkRequestValidationError{
					field:  "Open",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TalkRequest_Message:

		if all {
			switch v := interface{}(m.GetMessage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TalkRequestValidationError{
						field:  "Message",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TalkRequestValidationError{
						field:  "Message",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMessage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TalkRequestValidationError{
					field:  "Message",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TalkRequest_Close:

		if all {
			switch v := interface{}(m.GetClose()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TalkRequestValidationError{
						field:  "Close",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TalkRequestValidationError{
						field:  "Close",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetClose()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TalkRequestValidationError{
					field:  "Close",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TalkRequestMultiError(errors)
	}

	return nil
}

// TalkRequestMultiError is an error wrapping multiple validation errors
// returned by TalkRequest.ValidateAll() if the designated constraints aren't met.
type TalkRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TalkRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TalkRequestMultiError) AllErrors() []error { return m }

// TalkRequestValidationError is the validation error returned by
// TalkRequest.Validate if the designated constraints aren't met.
type TalkRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TalkRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TalkRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TalkRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TalkRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TalkRequestValidationError) ErrorName() string { return "TalkRequestValidationError" }

// Error satisfies the builtin error interface
func (e TalkRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTalkRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TalkRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TalkRequestValidationError{}

// Validate checks the field values on TalkMessages with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TalkMessages) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TalkMessages with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TalkMessagesMultiError, or
// nil if none found.
func (m *TalkMessages) ValidateAll() error {
	return m.validate(true)
}

func (m *TalkMessages) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TalkId

	for idx, item := range m.GetMessages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TalkMessagesValidationError{
						field:  fmt.Sprintf("Messages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TalkMessagesValidationError{
						field:  fmt.Sprintf("Messages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TalkMessagesValidationError{
					field:  fmt.Sprintf("Messages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TalkMessagesMultiError(errors)
	}

	return nil
}

// TalkMessagesMultiError is an error wrapping multiple validation errors
// returned by TalkMessages.ValidateAll() if the designated constraints aren't met.
type TalkMessagesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TalkMessagesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TalkMessagesMultiError) AllErrors() []error { return m }

// TalkMessagesValidationError is the validation error returned by
// TalkMessages.Validate if the designated constraints aren't met.
type TalkMessagesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TalkMessagesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TalkMessagesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TalkMessagesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TalkMessagesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TalkMessagesValidationError) ErrorName() string { return "TalkMessagesValidationError" }

// Error satisfies the builtin error interface
func (e TalkMessagesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTalkMessages.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TalkMessagesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TalkMessagesValidationError{}

// Validate checks the field values on TalkMessageConfirmed with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TalkMessageConfirmed) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TalkMessageConfirmed with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TalkMessageConfirmedMultiError, or nil if none found.
func (m *TalkMessageConfirmed) ValidateAll() error {
	return m.validate(true)
}

func (m *TalkMessageConfirmed) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SeqId

	// no validation rules for At

	if len(errors) > 0 {
		return TalkMessageConfirmedMultiError(errors)
	}

	return nil
}

// TalkMessageConfirmedMultiError is an error wrapping multiple validation
// errors returned by TalkMessageConfirmed.ValidateAll() if the designated
// constraints aren't met.
type TalkMessageConfirmedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TalkMessageConfirmedMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TalkMessageConfirmedMultiError) AllErrors() []error { return m }

// TalkMessageConfirmedValidationError is the validation error returned by
// TalkMessageConfirmed.Validate if the designated constraints aren't met.
type TalkMessageConfirmedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TalkMessageConfirmedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TalkMessageConfirmedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TalkMessageConfirmedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TalkMessageConfirmedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TalkMessageConfirmedValidationError) ErrorName() string {
	return "TalkMessageConfirmedValidationError"
}

// Error satisfies the builtin error interface
func (e TalkMessageConfirmedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTalkMessageConfirmed.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TalkMessageConfirmedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TalkMessageConfirmedValidationError{}

// Validate checks the field values on TalkNotifyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TalkNotifyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TalkNotifyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TalkNotifyResponseMultiError, or nil if none found.
func (m *TalkNotifyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TalkNotifyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Msg

	if len(errors) > 0 {
		return TalkNotifyResponseMultiError(errors)
	}

	return nil
}

// TalkNotifyResponseMultiError is an error wrapping multiple validation errors
// returned by TalkNotifyResponse.ValidateAll() if the designated constraints
// aren't met.
type TalkNotifyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TalkNotifyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TalkNotifyResponseMultiError) AllErrors() []error { return m }

// TalkNotifyResponseValidationError is the validation error returned by
// TalkNotifyResponse.Validate if the designated constraints aren't met.
type TalkNotifyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TalkNotifyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TalkNotifyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TalkNotifyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TalkNotifyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TalkNotifyResponseValidationError) ErrorName() string {
	return "TalkNotifyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TalkNotifyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTalkNotifyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TalkNotifyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TalkNotifyResponseValidationError{}

// Validate checks the field values on TalkResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TalkResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TalkResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TalkResponseMultiError, or
// nil if none found.
func (m *TalkResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TalkResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Talk.(type) {

	case *TalkResponse_KickOut:

		if all {
			switch v := interface{}(m.GetKickOut()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TalkResponseValidationError{
						field:  "KickOut",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TalkResponseValidationError{
						field:  "KickOut",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKickOut()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TalkResponseValidationError{
					field:  "KickOut",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TalkResponse_Messages:

		if all {
			switch v := interface{}(m.GetMessages()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TalkResponseValidationError{
						field:  "Messages",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TalkResponseValidationError{
						field:  "Messages",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMessages()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TalkResponseValidationError{
					field:  "Messages",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TalkResponse_Message:

		if all {
			switch v := interface{}(m.GetMessage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TalkResponseValidationError{
						field:  "Message",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TalkResponseValidationError{
						field:  "Message",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMessage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TalkResponseValidationError{
					field:  "Message",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TalkResponse_MessageConfirmed:

		if all {
			switch v := interface{}(m.GetMessageConfirmed()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TalkResponseValidationError{
						field:  "MessageConfirmed",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TalkResponseValidationError{
						field:  "MessageConfirmed",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMessageConfirmed()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TalkResponseValidationError{
					field:  "MessageConfirmed",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TalkResponse_Close:

		if all {
			switch v := interface{}(m.GetClose()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TalkResponseValidationError{
						field:  "Close",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TalkResponseValidationError{
						field:  "Close",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetClose()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TalkResponseValidationError{
					field:  "Close",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TalkResponse_Notify:

		if all {
			switch v := interface{}(m.GetNotify()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TalkResponseValidationError{
						field:  "Notify",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TalkResponseValidationError{
						field:  "Notify",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNotify()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TalkResponseValidationError{
					field:  "Notify",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TalkResponseMultiError(errors)
	}

	return nil
}

// TalkResponseMultiError is an error wrapping multiple validation errors
// returned by TalkResponse.ValidateAll() if the designated constraints aren't met.
type TalkResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TalkResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TalkResponseMultiError) AllErrors() []error { return m }

// TalkResponseValidationError is the validation error returned by
// TalkResponse.Validate if the designated constraints aren't met.
type TalkResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TalkResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TalkResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TalkResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TalkResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TalkResponseValidationError) ErrorName() string { return "TalkResponseValidationError" }

// Error satisfies the builtin error interface
func (e TalkResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTalkResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TalkResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TalkResponseValidationError{}

// Validate checks the field values on ServiceQueryAttachedTalksRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ServiceQueryAttachedTalksRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceQueryAttachedTalksRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ServiceQueryAttachedTalksRequestMultiError, or nil if none found.
func (m *ServiceQueryAttachedTalksRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceQueryAttachedTalksRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ServiceQueryAttachedTalksRequestMultiError(errors)
	}

	return nil
}

// ServiceQueryAttachedTalksRequestMultiError is an error wrapping multiple
// validation errors returned by
// ServiceQueryAttachedTalksRequest.ValidateAll() if the designated
// constraints aren't met.
type ServiceQueryAttachedTalksRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceQueryAttachedTalksRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceQueryAttachedTalksRequestMultiError) AllErrors() []error { return m }

// ServiceQueryAttachedTalksRequestValidationError is the validation error
// returned by ServiceQueryAttachedTalksRequest.Validate if the designated
// constraints aren't met.
type ServiceQueryAttachedTalksRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceQueryAttachedTalksRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceQueryAttachedTalksRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceQueryAttachedTalksRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceQueryAttachedTalksRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceQueryAttachedTalksRequestValidationError) ErrorName() string {
	return "ServiceQueryAttachedTalksRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceQueryAttachedTalksRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceQueryAttachedTalksRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceQueryAttachedTalksRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceQueryAttachedTalksRequestValidationError{}

// Validate checks the field values on ServiceQueryPendingTalksRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceQueryPendingTalksRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceQueryPendingTalksRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ServiceQueryPendingTalksRequestMultiError, or nil if none found.
func (m *ServiceQueryPendingTalksRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceQueryPendingTalksRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ServiceQueryPendingTalksRequestMultiError(errors)
	}

	return nil
}

// ServiceQueryPendingTalksRequestMultiError is an error wrapping multiple
// validation errors returned by ServiceQueryPendingTalksRequest.ValidateAll()
// if the designated constraints aren't met.
type ServiceQueryPendingTalksRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceQueryPendingTalksRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceQueryPendingTalksRequestMultiError) AllErrors() []error { return m }

// ServiceQueryPendingTalksRequestValidationError is the validation error
// returned by ServiceQueryPendingTalksRequest.Validate if the designated
// constraints aren't met.
type ServiceQueryPendingTalksRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceQueryPendingTalksRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceQueryPendingTalksRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceQueryPendingTalksRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceQueryPendingTalksRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceQueryPendingTalksRequestValidationError) ErrorName() string {
	return "ServiceQueryPendingTalksRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceQueryPendingTalksRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceQueryPendingTalksRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceQueryPendingTalksRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceQueryPendingTalksRequestValidationError{}

// Validate checks the field values on ServiceReloadTalkRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceReloadTalkRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceReloadTalkRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceReloadTalkRequestMultiError, or nil if none found.
func (m *ServiceReloadTalkRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceReloadTalkRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TalkId

	if len(errors) > 0 {
		return ServiceReloadTalkRequestMultiError(errors)
	}

	return nil
}

// ServiceReloadTalkRequestMultiError is an error wrapping multiple validation
// errors returned by ServiceReloadTalkRequest.ValidateAll() if the designated
// constraints aren't met.
type ServiceReloadTalkRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceReloadTalkRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceReloadTalkRequestMultiError) AllErrors() []error { return m }

// ServiceReloadTalkRequestValidationError is the validation error returned by
// ServiceReloadTalkRequest.Validate if the designated constraints aren't met.
type ServiceReloadTalkRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceReloadTalkRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceReloadTalkRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceReloadTalkRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceReloadTalkRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceReloadTalkRequestValidationError) ErrorName() string {
	return "ServiceReloadTalkRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceReloadTalkRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceReloadTalkRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceReloadTalkRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceReloadTalkRequestValidationError{}

// Validate checks the field values on ServicePostMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServicePostMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServicePostMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServicePostMessageMultiError, or nil if none found.
func (m *ServicePostMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *ServicePostMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TalkId

	if all {
		switch v := interface{}(m.GetMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServicePostMessageValidationError{
					field:  "Message",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServicePostMessageValidationError{
					field:  "Message",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServicePostMessageValidationError{
				field:  "Message",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ServicePostMessageMultiError(errors)
	}

	return nil
}

// ServicePostMessageMultiError is an error wrapping multiple validation errors
// returned by ServicePostMessage.ValidateAll() if the designated constraints
// aren't met.
type ServicePostMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServicePostMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServicePostMessageMultiError) AllErrors() []error { return m }

// ServicePostMessageValidationError is the validation error returned by
// ServicePostMessage.Validate if the designated constraints aren't met.
type ServicePostMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServicePostMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServicePostMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServicePostMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServicePostMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServicePostMessageValidationError) ErrorName() string {
	return "ServicePostMessageValidationError"
}

// Error satisfies the builtin error interface
func (e ServicePostMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServicePostMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServicePostMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServicePostMessageValidationError{}

// Validate checks the field values on ServiceAttachRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceAttachRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceAttachRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceAttachRequestMultiError, or nil if none found.
func (m *ServiceAttachRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceAttachRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TalkId

	if len(errors) > 0 {
		return ServiceAttachRequestMultiError(errors)
	}

	return nil
}

// ServiceAttachRequestMultiError is an error wrapping multiple validation
// errors returned by ServiceAttachRequest.ValidateAll() if the designated
// constraints aren't met.
type ServiceAttachRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceAttachRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceAttachRequestMultiError) AllErrors() []error { return m }

// ServiceAttachRequestValidationError is the validation error returned by
// ServiceAttachRequest.Validate if the designated constraints aren't met.
type ServiceAttachRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceAttachRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceAttachRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceAttachRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceAttachRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceAttachRequestValidationError) ErrorName() string {
	return "ServiceAttachRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceAttachRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceAttachRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceAttachRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceAttachRequestValidationError{}

// Validate checks the field values on ServiceDetachRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceDetachRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceDetachRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceDetachRequestMultiError, or nil if none found.
func (m *ServiceDetachRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceDetachRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TalkId

	if len(errors) > 0 {
		return ServiceDetachRequestMultiError(errors)
	}

	return nil
}

// ServiceDetachRequestMultiError is an error wrapping multiple validation
// errors returned by ServiceDetachRequest.ValidateAll() if the designated
// constraints aren't met.
type ServiceDetachRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceDetachRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceDetachRequestMultiError) AllErrors() []error { return m }

// ServiceDetachRequestValidationError is the validation error returned by
// ServiceDetachRequest.Validate if the designated constraints aren't met.
type ServiceDetachRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceDetachRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceDetachRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceDetachRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceDetachRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceDetachRequestValidationError) ErrorName() string {
	return "ServiceDetachRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceDetachRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceDetachRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceDetachRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceDetachRequestValidationError{}

// Validate checks the field values on ServiceRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ServiceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ServiceRequestMultiError,
// or nil if none found.
func (m *ServiceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Request.(type) {

	case *ServiceRequest_AttachedTalks:

		if all {
			switch v := interface{}(m.GetAttachedTalks()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceRequestValidationError{
						field:  "AttachedTalks",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceRequestValidationError{
						field:  "AttachedTalks",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAttachedTalks()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceRequestValidationError{
					field:  "AttachedTalks",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServiceRequest_PendingTalks:

		if all {
			switch v := interface{}(m.GetPendingTalks()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceRequestValidationError{
						field:  "PendingTalks",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceRequestValidationError{
						field:  "PendingTalks",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPendingTalks()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceRequestValidationError{
					field:  "PendingTalks",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServiceRequest_Reload:

		if all {
			switch v := interface{}(m.GetReload()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceRequestValidationError{
						field:  "Reload",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceRequestValidationError{
						field:  "Reload",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReload()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceRequestValidationError{
					field:  "Reload",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServiceRequest_Message:

		if all {
			switch v := interface{}(m.GetMessage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceRequestValidationError{
						field:  "Message",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceRequestValidationError{
						field:  "Message",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMessage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceRequestValidationError{
					field:  "Message",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServiceRequest_Attach:

		if all {
			switch v := interface{}(m.GetAttach()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceRequestValidationError{
						field:  "Attach",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceRequestValidationError{
						field:  "Attach",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAttach()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceRequestValidationError{
					field:  "Attach",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServiceRequest_Detach:

		if all {
			switch v := interface{}(m.GetDetach()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceRequestValidationError{
						field:  "Detach",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceRequestValidationError{
						field:  "Detach",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDetach()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceRequestValidationError{
					field:  "Detach",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ServiceRequestMultiError(errors)
	}

	return nil
}

// ServiceRequestMultiError is an error wrapping multiple validation errors
// returned by ServiceRequest.ValidateAll() if the designated constraints
// aren't met.
type ServiceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceRequestMultiError) AllErrors() []error { return m }

// ServiceRequestValidationError is the validation error returned by
// ServiceRequest.Validate if the designated constraints aren't met.
type ServiceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceRequestValidationError) ErrorName() string { return "ServiceRequestValidationError" }

// Error satisfies the builtin error interface
func (e ServiceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceRequestValidationError{}

// Validate checks the field values on ServicePendingTalksResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServicePendingTalksResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServicePendingTalksResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServicePendingTalksResponseMultiError, or nil if none found.
func (m *ServicePendingTalksResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ServicePendingTalksResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTalks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServicePendingTalksResponseValidationError{
						field:  fmt.Sprintf("Talks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServicePendingTalksResponseValidationError{
						field:  fmt.Sprintf("Talks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServicePendingTalksResponseValidationError{
					field:  fmt.Sprintf("Talks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ServicePendingTalksResponseMultiError(errors)
	}

	return nil
}

// ServicePendingTalksResponseMultiError is an error wrapping multiple
// validation errors returned by ServicePendingTalksResponse.ValidateAll() if
// the designated constraints aren't met.
type ServicePendingTalksResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServicePendingTalksResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServicePendingTalksResponseMultiError) AllErrors() []error { return m }

// ServicePendingTalksResponseValidationError is the validation error returned
// by ServicePendingTalksResponse.Validate if the designated constraints
// aren't met.
type ServicePendingTalksResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServicePendingTalksResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServicePendingTalksResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServicePendingTalksResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServicePendingTalksResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServicePendingTalksResponseValidationError) ErrorName() string {
	return "ServicePendingTalksResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ServicePendingTalksResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServicePendingTalksResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServicePendingTalksResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServicePendingTalksResponseValidationError{}

// Validate checks the field values on ServiceTalkInfoAndMessages with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceTalkInfoAndMessages) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceTalkInfoAndMessages with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceTalkInfoAndMessagesMultiError, or nil if none found.
func (m *ServiceTalkInfoAndMessages) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceTalkInfoAndMessages) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTalkInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceTalkInfoAndMessagesValidationError{
					field:  "TalkInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceTalkInfoAndMessagesValidationError{
					field:  "TalkInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTalkInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceTalkInfoAndMessagesValidationError{
				field:  "TalkInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetMessages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceTalkInfoAndMessagesValidationError{
						field:  fmt.Sprintf("Messages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceTalkInfoAndMessagesValidationError{
						field:  fmt.Sprintf("Messages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceTalkInfoAndMessagesValidationError{
					field:  fmt.Sprintf("Messages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ServiceTalkInfoAndMessagesMultiError(errors)
	}

	return nil
}

// ServiceTalkInfoAndMessagesMultiError is an error wrapping multiple
// validation errors returned by ServiceTalkInfoAndMessages.ValidateAll() if
// the designated constraints aren't met.
type ServiceTalkInfoAndMessagesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceTalkInfoAndMessagesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceTalkInfoAndMessagesMultiError) AllErrors() []error { return m }

// ServiceTalkInfoAndMessagesValidationError is the validation error returned
// by ServiceTalkInfoAndMessages.Validate if the designated constraints aren't met.
type ServiceTalkInfoAndMessagesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceTalkInfoAndMessagesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceTalkInfoAndMessagesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceTalkInfoAndMessagesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceTalkInfoAndMessagesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceTalkInfoAndMessagesValidationError) ErrorName() string {
	return "ServiceTalkInfoAndMessagesValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceTalkInfoAndMessagesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceTalkInfoAndMessages.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceTalkInfoAndMessagesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceTalkInfoAndMessagesValidationError{}

// Validate checks the field values on ServiceAttachedTalksResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceAttachedTalksResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceAttachedTalksResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceAttachedTalksResponseMultiError, or nil if none found.
func (m *ServiceAttachedTalksResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceAttachedTalksResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTalks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceAttachedTalksResponseValidationError{
						field:  fmt.Sprintf("Talks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceAttachedTalksResponseValidationError{
						field:  fmt.Sprintf("Talks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceAttachedTalksResponseValidationError{
					field:  fmt.Sprintf("Talks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ServiceAttachedTalksResponseMultiError(errors)
	}

	return nil
}

// ServiceAttachedTalksResponseMultiError is an error wrapping multiple
// validation errors returned by ServiceAttachedTalksResponse.ValidateAll() if
// the designated constraints aren't met.
type ServiceAttachedTalksResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceAttachedTalksResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceAttachedTalksResponseMultiError) AllErrors() []error { return m }

// ServiceAttachedTalksResponseValidationError is the validation error returned
// by ServiceAttachedTalksResponse.Validate if the designated constraints
// aren't met.
type ServiceAttachedTalksResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceAttachedTalksResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceAttachedTalksResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceAttachedTalksResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceAttachedTalksResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceAttachedTalksResponseValidationError) ErrorName() string {
	return "ServiceAttachedTalksResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceAttachedTalksResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceAttachedTalksResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceAttachedTalksResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceAttachedTalksResponseValidationError{}

// Validate checks the field values on ServiceAttachTalkResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceAttachTalkResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceAttachTalkResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceAttachTalkResponseMultiError, or nil if none found.
func (m *ServiceAttachTalkResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceAttachTalkResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTalk()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAttachTalkResponseValidationError{
					field:  "Talk",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAttachTalkResponseValidationError{
					field:  "Talk",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTalk()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAttachTalkResponseValidationError{
				field:  "Talk",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AttachedServiceId

	if len(errors) > 0 {
		return ServiceAttachTalkResponseMultiError(errors)
	}

	return nil
}

// ServiceAttachTalkResponseMultiError is an error wrapping multiple validation
// errors returned by ServiceAttachTalkResponse.ValidateAll() if the
// designated constraints aren't met.
type ServiceAttachTalkResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceAttachTalkResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceAttachTalkResponseMultiError) AllErrors() []error { return m }

// ServiceAttachTalkResponseValidationError is the validation error returned by
// ServiceAttachTalkResponse.Validate if the designated constraints aren't met.
type ServiceAttachTalkResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceAttachTalkResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceAttachTalkResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceAttachTalkResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceAttachTalkResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceAttachTalkResponseValidationError) ErrorName() string {
	return "ServiceAttachTalkResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceAttachTalkResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceAttachTalkResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceAttachTalkResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceAttachTalkResponseValidationError{}

// Validate checks the field values on ServiceDetachTalkResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceDetachTalkResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceDetachTalkResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceDetachTalkResponseMultiError, or nil if none found.
func (m *ServiceDetachTalkResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceDetachTalkResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTalk()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceDetachTalkResponseValidationError{
					field:  "Talk",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceDetachTalkResponseValidationError{
					field:  "Talk",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTalk()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceDetachTalkResponseValidationError{
				field:  "Talk",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DetachedServiceId

	if len(errors) > 0 {
		return ServiceDetachTalkResponseMultiError(errors)
	}

	return nil
}

// ServiceDetachTalkResponseMultiError is an error wrapping multiple validation
// errors returned by ServiceDetachTalkResponse.ValidateAll() if the
// designated constraints aren't met.
type ServiceDetachTalkResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceDetachTalkResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceDetachTalkResponseMultiError) AllErrors() []error { return m }

// ServiceDetachTalkResponseValidationError is the validation error returned by
// ServiceDetachTalkResponse.Validate if the designated constraints aren't met.
type ServiceDetachTalkResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceDetachTalkResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceDetachTalkResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceDetachTalkResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceDetachTalkResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceDetachTalkResponseValidationError) ErrorName() string {
	return "ServiceDetachTalkResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceDetachTalkResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceDetachTalkResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceDetachTalkResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceDetachTalkResponseValidationError{}

// Validate checks the field values on ServiceTalkReloadResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceTalkReloadResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceTalkReloadResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceTalkReloadResponseMultiError, or nil if none found.
func (m *ServiceTalkReloadResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceTalkReloadResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTalk()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceTalkReloadResponseValidationError{
					field:  "Talk",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceTalkReloadResponseValidationError{
					field:  "Talk",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTalk()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceTalkReloadResponseValidationError{
				field:  "Talk",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ServiceTalkReloadResponseMultiError(errors)
	}

	return nil
}

// ServiceTalkReloadResponseMultiError is an error wrapping multiple validation
// errors returned by ServiceTalkReloadResponse.ValidateAll() if the
// designated constraints aren't met.
type ServiceTalkReloadResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceTalkReloadResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceTalkReloadResponseMultiError) AllErrors() []error { return m }

// ServiceTalkReloadResponseValidationError is the validation error returned by
// ServiceTalkReloadResponse.Validate if the designated constraints aren't met.
type ServiceTalkReloadResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceTalkReloadResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceTalkReloadResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceTalkReloadResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceTalkReloadResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceTalkReloadResponseValidationError) ErrorName() string {
	return "ServiceTalkReloadResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceTalkReloadResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceTalkReloadResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceTalkReloadResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceTalkReloadResponseValidationError{}

// Validate checks the field values on ServiceTalkMessageResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceTalkMessageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceTalkMessageResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceTalkMessageResponseMultiError, or nil if none found.
func (m *ServiceTalkMessageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceTalkMessageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TalkId

	if all {
		switch v := interface{}(m.GetMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceTalkMessageResponseValidationError{
					field:  "Message",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceTalkMessageResponseValidationError{
					field:  "Message",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceTalkMessageResponseValidationError{
				field:  "Message",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ServiceTalkMessageResponseMultiError(errors)
	}

	return nil
}

// ServiceTalkMessageResponseMultiError is an error wrapping multiple
// validation errors returned by ServiceTalkMessageResponse.ValidateAll() if
// the designated constraints aren't met.
type ServiceTalkMessageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceTalkMessageResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceTalkMessageResponseMultiError) AllErrors() []error { return m }

// ServiceTalkMessageResponseValidationError is the validation error returned
// by ServiceTalkMessageResponse.Validate if the designated constraints aren't met.
type ServiceTalkMessageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceTalkMessageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceTalkMessageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceTalkMessageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceTalkMessageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceTalkMessageResponseValidationError) ErrorName() string {
	return "ServiceTalkMessageResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceTalkMessageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceTalkMessageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceTalkMessageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceTalkMessageResponseValidationError{}

// Validate checks the field values on ServiceTalkNotifyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceTalkNotifyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceTalkNotifyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceTalkNotifyResponseMultiError, or nil if none found.
func (m *ServiceTalkNotifyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceTalkNotifyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Msg

	if len(errors) > 0 {
		return ServiceTalkNotifyResponseMultiError(errors)
	}

	return nil
}

// ServiceTalkNotifyResponseMultiError is an error wrapping multiple validation
// errors returned by ServiceTalkNotifyResponse.ValidateAll() if the
// designated constraints aren't met.
type ServiceTalkNotifyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceTalkNotifyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceTalkNotifyResponseMultiError) AllErrors() []error { return m }

// ServiceTalkNotifyResponseValidationError is the validation error returned by
// ServiceTalkNotifyResponse.Validate if the designated constraints aren't met.
type ServiceTalkNotifyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceTalkNotifyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceTalkNotifyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceTalkNotifyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceTalkNotifyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceTalkNotifyResponseValidationError) ErrorName() string {
	return "ServiceTalkNotifyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceTalkNotifyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceTalkNotifyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceTalkNotifyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceTalkNotifyResponseValidationError{}

// Validate checks the field values on ServiceMessageConfirmed with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceMessageConfirmed) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceMessageConfirmed with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceMessageConfirmedMultiError, or nil if none found.
func (m *ServiceMessageConfirmed) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceMessageConfirmed) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SeqId

	// no validation rules for At

	if len(errors) > 0 {
		return ServiceMessageConfirmedMultiError(errors)
	}

	return nil
}

// ServiceMessageConfirmedMultiError is an error wrapping multiple validation
// errors returned by ServiceMessageConfirmed.ValidateAll() if the designated
// constraints aren't met.
type ServiceMessageConfirmedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceMessageConfirmedMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceMessageConfirmedMultiError) AllErrors() []error { return m }

// ServiceMessageConfirmedValidationError is the validation error returned by
// ServiceMessageConfirmed.Validate if the designated constraints aren't met.
type ServiceMessageConfirmedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceMessageConfirmedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceMessageConfirmedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceMessageConfirmedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceMessageConfirmedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceMessageConfirmedValidationError) ErrorName() string {
	return "ServiceMessageConfirmedValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceMessageConfirmedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceMessageConfirmed.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceMessageConfirmedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceMessageConfirmedValidationError{}

// Validate checks the field values on ServiceTalkClose with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ServiceTalkClose) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceTalkClose with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceTalkCloseMultiError, or nil if none found.
func (m *ServiceTalkClose) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceTalkClose) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TalkId

	if len(errors) > 0 {
		return ServiceTalkCloseMultiError(errors)
	}

	return nil
}

// ServiceTalkCloseMultiError is an error wrapping multiple validation errors
// returned by ServiceTalkClose.ValidateAll() if the designated constraints
// aren't met.
type ServiceTalkCloseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceTalkCloseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceTalkCloseMultiError) AllErrors() []error { return m }

// ServiceTalkCloseValidationError is the validation error returned by
// ServiceTalkClose.Validate if the designated constraints aren't met.
type ServiceTalkCloseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceTalkCloseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceTalkCloseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceTalkCloseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceTalkCloseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceTalkCloseValidationError) ErrorName() string { return "ServiceTalkCloseValidationError" }

// Error satisfies the builtin error interface
func (e ServiceTalkCloseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceTalkClose.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceTalkCloseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceTalkCloseValidationError{}

// Validate checks the field values on ServiceResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ServiceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceResponseMultiError, or nil if none found.
func (m *ServiceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Response.(type) {

	case *ServiceResponse_KickOut:

		if all {
			switch v := interface{}(m.GetKickOut()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceResponseValidationError{
						field:  "KickOut",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceResponseValidationError{
						field:  "KickOut",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKickOut()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceResponseValidationError{
					field:  "KickOut",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServiceResponse_PendingTalks:

		if all {
			switch v := interface{}(m.GetPendingTalks()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceResponseValidationError{
						field:  "PendingTalks",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceResponseValidationError{
						field:  "PendingTalks",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPendingTalks()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceResponseValidationError{
					field:  "PendingTalks",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServiceResponse_Talks:

		if all {
			switch v := interface{}(m.GetTalks()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceResponseValidationError{
						field:  "Talks",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceResponseValidationError{
						field:  "Talks",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTalks()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceResponseValidationError{
					field:  "Talks",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServiceResponse_Attach:

		if all {
			switch v := interface{}(m.GetAttach()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceResponseValidationError{
						field:  "Attach",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceResponseValidationError{
						field:  "Attach",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAttach()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceResponseValidationError{
					field:  "Attach",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServiceResponse_Detach:

		if all {
			switch v := interface{}(m.GetDetach()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceResponseValidationError{
						field:  "Detach",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceResponseValidationError{
						field:  "Detach",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDetach()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceResponseValidationError{
					field:  "Detach",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServiceResponse_Reload:

		if all {
			switch v := interface{}(m.GetReload()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceResponseValidationError{
						field:  "Reload",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceResponseValidationError{
						field:  "Reload",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReload()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceResponseValidationError{
					field:  "Reload",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServiceResponse_Message:

		if all {
			switch v := interface{}(m.GetMessage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceResponseValidationError{
						field:  "Message",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceResponseValidationError{
						field:  "Message",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMessage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceResponseValidationError{
					field:  "Message",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServiceResponse_Notify:

		if all {
			switch v := interface{}(m.GetNotify()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceResponseValidationError{
						field:  "Notify",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceResponseValidationError{
						field:  "Notify",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNotify()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceResponseValidationError{
					field:  "Notify",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServiceResponse_MessageConfirmed:

		if all {
			switch v := interface{}(m.GetMessageConfirmed()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceResponseValidationError{
						field:  "MessageConfirmed",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceResponseValidationError{
						field:  "MessageConfirmed",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMessageConfirmed()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceResponseValidationError{
					field:  "MessageConfirmed",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServiceResponse_Close:

		if all {
			switch v := interface{}(m.GetClose()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceResponseValidationError{
						field:  "Close",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceResponseValidationError{
						field:  "Close",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetClose()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceResponseValidationError{
					field:  "Close",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ServiceResponseMultiError(errors)
	}

	return nil
}

// ServiceResponseMultiError is an error wrapping multiple validation errors
// returned by ServiceResponse.ValidateAll() if the designated constraints
// aren't met.
type ServiceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceResponseMultiError) AllErrors() []error { return m }

// ServiceResponseValidationError is the validation error returned by
// ServiceResponse.Validate if the designated constraints aren't met.
type ServiceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceResponseValidationError) ErrorName() string { return "ServiceResponseValidationError" }

// Error satisfies the builtin error interface
func (e ServiceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceResponseValidationError{}

// Validate checks the field values on CheckTokenRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CheckTokenRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckTokenRequestMultiError, or nil if none found.
func (m *CheckTokenRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckTokenRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CheckTokenRequestMultiError(errors)
	}

	return nil
}

// CheckTokenRequestMultiError is an error wrapping multiple validation errors
// returned by CheckTokenRequest.ValidateAll() if the designated constraints
// aren't met.
type CheckTokenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckTokenRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckTokenRequestMultiError) AllErrors() []error { return m }

// CheckTokenRequestValidationError is the validation error returned by
// CheckTokenRequest.Validate if the designated constraints aren't met.
type CheckTokenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckTokenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckTokenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckTokenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckTokenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckTokenRequestValidationError) ErrorName() string {
	return "CheckTokenRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CheckTokenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckTokenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckTokenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckTokenRequestValidationError{}

// Validate checks the field values on CheckTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckTokenResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckTokenResponseMultiError, or nil if none found.
func (m *CheckTokenResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckTokenResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Valid

	// no validation rules for UserName

	// no validation rules for NewToken

	if len(errors) > 0 {
		return CheckTokenResponseMultiError(errors)
	}

	return nil
}

// CheckTokenResponseMultiError is an error wrapping multiple validation errors
// returned by CheckTokenResponse.ValidateAll() if the designated constraints
// aren't met.
type CheckTokenResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckTokenResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckTokenResponseMultiError) AllErrors() []error { return m }

// CheckTokenResponseValidationError is the validation error returned by
// CheckTokenResponse.Validate if the designated constraints aren't met.
type CheckTokenResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckTokenResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckTokenResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckTokenResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckTokenResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckTokenResponseValidationError) ErrorName() string {
	return "CheckTokenResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CheckTokenResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckTokenResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckTokenResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckTokenResponseValidationError{}

// Validate checks the field values on CreateTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTokenRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTokenRequestMultiError, or nil if none found.
func (m *CreateTokenRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTokenRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserName

	if len(errors) > 0 {
		return CreateTokenRequestMultiError(errors)
	}

	return nil
}

// CreateTokenRequestMultiError is an error wrapping multiple validation errors
// returned by CreateTokenRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateTokenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTokenRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTokenRequestMultiError) AllErrors() []error { return m }

// CreateTokenRequestValidationError is the validation error returned by
// CreateTokenRequest.Validate if the designated constraints aren't met.
type CreateTokenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTokenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTokenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTokenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTokenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTokenRequestValidationError) ErrorName() string {
	return "CreateTokenRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTokenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTokenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTokenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTokenRequestValidationError{}

// Validate checks the field values on CreateTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTokenResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTokenResponseMultiError, or nil if none found.
func (m *CreateTokenResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTokenResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	// no validation rules for UserName

	if len(errors) > 0 {
		return CreateTokenResponseMultiError(errors)
	}

	return nil
}

// CreateTokenResponseMultiError is an error wrapping multiple validation
// errors returned by CreateTokenResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateTokenResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTokenResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTokenResponseMultiError) AllErrors() []error { return m }

// CreateTokenResponseValidationError is the validation error returned by
// CreateTokenResponse.Validate if the designated constraints aren't met.
type CreateTokenResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTokenResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTokenResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTokenResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTokenResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTokenResponseValidationError) ErrorName() string {
	return "CreateTokenResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTokenResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTokenResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTokenResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTokenResponseValidationError{}

// Validate checks the field values on RegisterRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RegisterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterRequestMultiError, or nil if none found.
func (m *RegisterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserName

	// no validation rules for Password

	if len(errors) > 0 {
		return RegisterRequestMultiError(errors)
	}

	return nil
}

// RegisterRequestMultiError is an error wrapping multiple validation errors
// returned by RegisterRequest.ValidateAll() if the designated constraints
// aren't met.
type RegisterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterRequestMultiError) AllErrors() []error { return m }

// RegisterRequestValidationError is the validation error returned by
// RegisterRequest.Validate if the designated constraints aren't met.
type RegisterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterRequestValidationError) ErrorName() string { return "RegisterRequestValidationError" }

// Error satisfies the builtin error interface
func (e RegisterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterRequestValidationError{}

// Validate checks the field values on RegisterResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RegisterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterResponseMultiError, or nil if none found.
func (m *RegisterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	// no validation rules for UserName

	if len(errors) > 0 {
		return RegisterResponseMultiError(errors)
	}

	return nil
}

// RegisterResponseMultiError is an error wrapping multiple validation errors
// returned by RegisterResponse.ValidateAll() if the designated constraints
// aren't met.
type RegisterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterResponseMultiError) AllErrors() []error { return m }

// RegisterResponseValidationError is the validation error returned by
// RegisterResponse.Validate if the designated constraints aren't met.
type RegisterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterResponseValidationError) ErrorName() string { return "RegisterResponseValidationError" }

// Error satisfies the builtin error interface
func (e RegisterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterResponseValidationError{}

// Validate checks the field values on LoginRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginRequestMultiError, or
// nil if none found.
func (m *LoginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserName

	// no validation rules for Password

	if len(errors) > 0 {
		return LoginRequestMultiError(errors)
	}

	return nil
}

// LoginRequestMultiError is an error wrapping multiple validation errors
// returned by LoginRequest.ValidateAll() if the designated constraints aren't met.
type LoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginRequestMultiError) AllErrors() []error { return m }

// LoginRequestValidationError is the validation error returned by
// LoginRequest.Validate if the designated constraints aren't met.
type LoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginRequestValidationError) ErrorName() string { return "LoginRequestValidationError" }

// Error satisfies the builtin error interface
func (e LoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginRequestValidationError{}

// Validate checks the field values on LoginResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginResponseMultiError, or
// nil if none found.
func (m *LoginResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	// no validation rules for UserName

	if len(errors) > 0 {
		return LoginResponseMultiError(errors)
	}

	return nil
}

// LoginResponseMultiError is an error wrapping multiple validation errors
// returned by LoginResponse.ValidateAll() if the designated constraints
// aren't met.
type LoginResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginResponseMultiError) AllErrors() []error { return m }

// LoginResponseValidationError is the validation error returned by
// LoginResponse.Validate if the designated constraints aren't met.
type LoginResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginResponseValidationError) ErrorName() string { return "LoginResponseValidationError" }

// Error satisfies the builtin error interface
func (e LoginResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginResponseValidationError{}
